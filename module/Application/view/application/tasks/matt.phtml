<style>.container{width:100%;height:100%;}</style>


<!--

This code is licenced under the same terms as Habitica:
    https://raw.githubusercontent.com/HabitRPG/habitrpg/develop/LICENSE

https://github.com/Alys/tools-for-habitrpg/blob/master/habitrpg_user_data_display.html
AND required JavaScript libraries:
https://github.com/Alys/tools-for-habitrpg/blob/master/js-for-habitrpg_user_data_display.tar.gz

https://oldgods.net/habitrpg/habitrpg_user_data_display.html
    or http://is.gd/hrpguserdata

Contributors:
    Alys (Alice Harris), lady_alys@oldgods.net https://github.com/Alys
    thepeopleseason (James Hsiao) https://github.com/thepeopleseason
    goldfndr (Richard Finegold) https://github.com/goldfndr
    Blade Barringer https://github.com/crookedneighbor
    donoftime https://github.com/donoftime
    me_and (Adam Dinwoodie) https://github.com/me-and


TO ADD A NEW SECTION TO THIS PAGE:
Search through this code to find all the comments that start
with "TO ADD NEW SECTION" and follow the (brief) instructions
you'll find there.


XXX TODO: Most Recent Streak https://github.com/Alys/tools-for-habitrpg/issues/34

-->


<!--
/////
/////
///// IMPORTANT NOTE TO PROGRAMMERS EDITING THIS PAGE:
/////
///// Do not add ANY features to this page which can modify a user's
///// account. This page is a read-only view of their current data.
/////
/////
-->


    <meta name="description" content="Habitica User Data Display Tool" />
    <meta name="author" content="Alys (Alice Harris) lady_alys@oldgods.net" />

    <link href="https://oldgods.net/habitrpg/js/DataTables/media/css/jquery.dataTables.css" rel="stylesheet" type="text/css" />
    <link href="https://oldgods.net/habitrpg/js/DataTables/extras/ColumnFilterWidgets/media/css/ColumnFilterWidgets.css" rel="stylesheet" type="text/css" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.10/c3.min.css" rel="stylesheet" type="text/css" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.10.3/moment.min.js"></script>
    <!-- script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.10/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/remarkable/1.6.2/remarkable.min.js"></script>

    <!--
    <script src="https://oldgods.net/habitrpg/js/DataTables/media/js/jquery.dataTables.js"></script>
    <script src="https://oldgods.net/habitrpg/js/DataTables/extras/ColumnFilterWidgets/media/js/ColumnFilterWidgets.js"></script>
    <script src="https://oldgods.net/habitrpg/js/emoji-images/emoji-images.js"></script>
    -->
    <script src="/js/DataTables/jquery.dataTables.js"></script>
    <script src="/js/DataTables/ColumnFilterWidgets.js"></script>
    <script src="/js/emoji-images/emoji-images.js"></script>

    <!-- TST - FOR TESTING
    For more information on using jquery-mockjax for simulating ajax requests, see https://github.com/jakerella/jquery-mockjax
    --><!--  The testdata files have not been updated for API v3. If you'd like to update and use them, you're welcome to submit a PR for them!
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-mockjax/1.5.3/jquery.mockjax.min.js" type="text/javascript"></script>
    <script src="testdata/content.js" type="text/javascript"></script>
    <script src="testdata/habits-many.js" type="text/javascript"></script>
    <script src="testdata/habits-very-many.js" type="text/javascript"></script>
    <script src="testdata/tavern.js" type="text/javascript"></script>
    <script src="testdata/user.js" type="text/javascript"></script>
    -->


<script type="text/javascript">
$(function() { // wraps around all our code to not pollute global namespace

    //////////////////////////////////////////////////////////////////////
    ////   Global Variables                              /////////////////
    //////////////////////////////////////////////////////////////////////
    var content;  // holds site-wide content (gear names and stats, quests, etc)
    var tavern;   // holds tavern data
    var party;    // holds party data
    var user;     // holds user's data
    var tasksFromDb;          // holds user's tasks except for ...
    var completedTodosFromDb; // completed To-Dos


    //////////////////////////////////////////////////////////////////////
    ////   Global Connection Variables      //////////////////////////////
    //////////////////////////////////////////////////////////////////////
    var serverName               = 'Habitica'; // used in "loading" message
    var serverUrl                = 'https://habitica.com/api/v3';
    var serverPathContent        = '/content?language=en';
    var serverPathTavern         = '/groups/habitrpg';
    var serverPathParty          = '/groups/party';
    var serverPathUser           = '/user';
    var serverPathTasks          = '/tasks/user';
    var serverPathCompletedTodos = '/tasks/user?type=_allCompletedTodos';
    var userId                   = '<?php echo $uid; ?>';
    var apiToken                 = '<?php echo $passkey; ?>';
    var debug                    = false;

    var markdown = new Remarkable({
        'html':       false,
        'linkify':    true,
        'linkTarget': '_blank',
    });

    /* TST - FOR TESTING:
    // Use this section if you do not have a local webserver and want to use the provided test data.
    // You can compose test data by doing things like:
    //     var userJson = JSON.parse(userJsonString);
    //     var habitsVeryManyJson = JSON.parse(habitsVeryManyJsonString);
    //     userJson.habits = habitsVeryManyJson;
    //     userJsonString = JSON.stringify(userJson);
    $.mockjax({
      url: serverUrl + serverPathContent,
      dataType: 'json',
      responseText: contentJsonString,
    });
    $.mockjax({
      url: serverUrl + serverPathTavern,
      dataType: 'json',
      responseText: tavernJsonString,
    });
    $.mockjax({
      url: serverUrl + serverPathParty,
      dataType: 'json',
      responseText: partyJsonString,
    });
    $.mockjax({
      url: serverUrl + serverPathUser,
      dataType: 'json',
      responseText: userJsonString,
    });
    $.mockjax({
      url: serverUrl + serverPathTasks,
      dataType: 'json',
      responseText: tasksJsonString,
    });
    $.mockjax({
      url: serverUrl + serverPathCompletedTodos,
      dataType: 'json',
      responseText: completedTodosJsonString,
    });
    */

    /* TST - FOR TESTING:
    // Use this section if you have a local webserver set up to handle the requests.
    serverName               = 'localhost';
    serverUrl                = 'http://localhost';
    serverPathTavern         = '/cgi-bin/hrpg_tavern.pl';
    serverPathParty          = '/cgi-bin/hrpg_party.pl';
    serverPathContent        = '/cgi-bin/hrpg_content.pl';
    serverPathUser           = '/cgi-bin/hrpg_user.pl';
    serverPathTasks          = '/cgi-bin/XXX.pl';
    serverPathTodosCompleted = '/cgi-bin/XXX.pl';
    apiToken                 = 'null';
    userId                   = 'test';
    userId                   = 'work';
    userId                   = 'home';
    */

    /* TST - FOR TESTING:
    $('body').css({'background-color':'#C4B4A4'});
    $('#userApiDetailsForm #userId').val(userId);
    $('#userApiDetailsForm #apiToken').val(apiToken);*/


    fetchData();

    if (debug) console.log('debug 1');

    var sectionOpen = 'taskOverviewSection'; // holds the ID attribute of a section of the page;
                          // persists through re-fetch of data so we can
                          // reopen that section when the new data arrives
    var hideDropsInDashboard = true; // changes to false as soon as the user
                                     // looks at the drops section, then remains
                                     // false through all future re-fetches
    var tellMe = '';


    //////////////////////////////////////////////////////////////////////
    ////   Allow Show/Hide Toggling to work    ///////////////////////////
    //////////////////////////////////////////////////////////////////////
    enableShowHideToggling(); // needed here to enable Version Changes link
    var openRelatedSections = function(){} // redefined later when user data exists
    function enableShowHideToggling() {
        // $('.showHideToggle').click(function(event)
        $('body').on('click', '.showHideToggle', function(event){
            var target = $(this).data("target");
            var wantToShow = (! $('#' + target).is(':visible')
                           || $(this).data("forceopen"));
                // wantToShow is false if the target is already open
                // (i.e., the user wants to close it)
                // unless the toggle's attributes force it to always be
                // opened (e.g., a link from the dashboard)
            var linktext = $(this).data("linktext") || false;
            if ($(this).data("closemainsections")) {
                $('#MAIN > *').hide();
            }
            if (wantToShow) {
                sectionOpen = target;
                $('#' + target).show();
                if (linktext) {
                    $(this).text('hide ' + linktext);
                }
                openRelatedSections();
            }
            else {
                $('#' + target).hide();
                if (linktext) {
                    $(this).text('show ' + linktext);
                }
                if ($(this).data("scrolltotop")) {
                    window.scrollTo(0, 0);
                }
            }
            var toggleTarget = $(this).data("resettoggletext") || false;
            if (toggleTarget) {
                $('#' + toggleTarget).text('show '
                            + $('#' + toggleTarget).data("linktext"));
            }

            // Enable Popovers
            $('[data-toggle="popover"]').popover({trigger:'hover focus click',html:true});
        });

        $('body').on('click', '.mainSectionClose', function(event){
            $('#MAIN > *').hide();
            window.scrollTo(0, 0);
        });
}


//////////////////////////////////////////////////////////////////////
////   Get UUID from URL      ////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
var url_vars = getUrlVars();
if (url_vars.uuid) {
    $("#userId").val(url_vars.uuid);
}
function getUrlVars() {
    // Function found at http://stackoverflow.com/questions/4656843/jquery-get-querystring-from-url#answer-4656873
    var vars = [], hash;
    var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
    for(var i = 0; i < hashes.length; i++)
    {
        hash = hashes[i].split('=');
        vars.push(hash[0]);
        vars[hash[0]] = hash[1];
    }
    return vars;
}


//////////////////////////////////////////////////////////////////////
////   Login events      /////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
$('#userApiDetailsForm').submit(function(event){
    /* The user manually submitted the API connection form. */
    userId   = $('#userId').val();
    apiToken = $('#apiToken').val();
    fetchData();
});


//////////////////////////////////////////////////////////////////////
////   Login and Data Fetch Functions   //////////////////////////////
//////////////////////////////////////////////////////////////////////
function fetchData() {
    if (debug) console.log('debug 2');
    if (userId == '3e595299-3d8a-4a10-bfe0-88f555e4aa0c' || // AliceHarris
        userId == 'e7b5d1e2-3b6e-4192-b867-8bafdb03eeec'    // Ryan
    ) {
        $('#specialMessage').show();
    }
    else {
        $('#specialMessage').hide();
    }
    $('#loading #serverName').text(serverName);
    $('#loading .good').show();
    $('#loading .bad' ).hide();

    var ajaxRunningCount = 6; // drops to 0 when all calls have succeeded

    // fetch the user's own content (gear owned, etc):
    $.ajax({
        url: serverUrl + serverPathUser,
        type: 'GET',
        dataType: 'json',
        cache: false,
        beforeSend: function(xhr){
                xhr.setRequestHeader('x-api-user', userId);
                xhr.setRequestHeader('x-api-key',  apiToken);
            },
        success: fetchUserSuccess,
        error: fetchFailure
    });

    // fetch the user's tasks (except completed To-Dos):
    $.ajax({
        url: serverUrl + serverPathTasks,
        type: 'GET',
        dataType: 'json',
        cache: false,
        beforeSend: function(xhr){
                xhr.setRequestHeader('x-api-user', userId);
                xhr.setRequestHeader('x-api-key',  apiToken);
            },
        success: fetchTasksSuccess,
        error: fetchFailure
    });

    // fetch the user's completed To-Dos:
    $.ajax({
        url: serverUrl + serverPathCompletedTodos,
        type: 'GET',
        dataType: 'json',
        cache: false,
        beforeSend: function(xhr){
                xhr.setRequestHeader('x-api-user', userId);
                xhr.setRequestHeader('x-api-key',  apiToken);
            },
        success: fetchCompletedTodosSuccess,
        error: fetchFailure
    });

    // fetch the site-wide content (gear names and stats, etc):
    $.ajax({
        url: serverUrl + serverPathContent,
        type: 'GET',
        dataType: 'json',
        cache: true,
        success: fetchContentSuccess,
        error: fetchFailure
    });

    // fetch tavern-specific content
    $.ajax({
        url: serverUrl + serverPathTavern,
        type: 'GET',
        dataType: 'json',
        cache: false,
        beforeSend: function(xhr){
                xhr.setRequestHeader('x-api-user', userId);
                xhr.setRequestHeader('x-api-key',  apiToken);
            },
        success: fetchTavernSuccess,
        error: fetchFailure,
    });

    // fetch party-specific content
    $.ajax({
        url: serverUrl + serverPathParty,
        type: 'GET',
        dataType: 'json',
        cache: false,
        beforeSend: function(xhr){
                xhr.setRequestHeader('x-api-user', userId);
                xhr.setRequestHeader('x-api-key',  apiToken);
            },
        success: fetchPartySuccess,
        error: function() { // assume no party
            party = {}; // no party
            ajaxRunningCount--;
            if (ajaxRunningCount === 0) { // all ajax calls have finished
                parseData();
            }
        },
    });

    function fetchFailure() {
        if (debug) console.log('debug fetchFailure start');
        $('#loading .good').hide();
        $('#loading .bad' ).show();
        $('#documentationAndForm').show(); // in case user has done a re-fetch
        $('#documentationAndFormClose').hide();
        if (debug) console.log('debug fetchFailure end');
    }
    function fetchContentSuccess(data) {
        if (debug) console.log('debug parseData Content success start');
        content = data.data;
        ajaxRunningCount--;
        if (ajaxRunningCount === 0) { // all ajax calls have finished
            parseData();
        }
    }
    function fetchTavernSuccess(data) {
        if (debug) console.log('debug parseData Tavern success start');
        tavern = data.data; // XXX_LATER test for world boss
        ajaxRunningCount--;
        if (ajaxRunningCount === 0) { // all ajax calls have finished
            parseData();
        }
    }
    function fetchPartySuccess(data) {
        if (debug) console.log('debug parseData Party success start');
        party = data.data;
        ajaxRunningCount--;
        if (ajaxRunningCount === 0) { // all ajax calls have finished
            parseData();
        }
    }
    function fetchUserSuccess(data) {
        if (debug) console.log('debug parseData User success start');
        user = data.data;
        ajaxRunningCount--;
        if (ajaxRunningCount === 0) { // all ajax calls have finished
            parseData();
        }
    }
    function fetchTasksSuccess(data) {
        if (debug) console.log('debug parseData Tasks success start');
        tasksFromDb = data.data;
        ajaxRunningCount--;
        if (ajaxRunningCount === 0) { // all ajax calls have finished
            parseData();
        }
    }
    function fetchCompletedTodosSuccess(data) {
        if (debug) console.log('debug parseData CompletedTodos success start');
        completedTodosFromDb = data.data;
        ajaxRunningCount--;
        if (ajaxRunningCount === 0) { // all ajax calls have finished
            parseData();
        }
    }
}
function parseData() {
    if (debug) console.log('debug parseData start');
    // variables for storing the content:
    var MAIN = {}; // each element defines the HTML for one section on the page
    var TOC  = {}; // each element defines one Table of Contents entry
    var DASHBOARD = {}; // each element defines the HTML for one dashboard tile

    convertTasksToApiV2Format();

    // save the fetch time early:
    var fetchtime = myDateConverter(new Date(), 'pretty');

    // extract some commonly-used data:
    var sleeping = user.preferences.sleep; // true if resting in the inn
    var userKlass = user.stats.class;
    var health = getCurrentHealth(); // also sets dashboard tile
    var quest = {};
    var questProgressUp = 0;
    var questProgressCollect = 0;
    var userIsOnBossQuest = false;
    var userIsOnCollectionQuest = false;
    if (party && user.party && user.party.quest) {
        if (party.quest && party.quest.active && party.quest.key && party.quest.members[userId]) {
            quest = $.extend({}, user.party.quest);
            quest.content = $.extend({}, content.quests[ party.quest.key ] );
            if  (quest.content.collect) userIsOnCollectionQuest = true;
            if (!quest.content.collect) userIsOnBossQuest = true;
        }
        if (user.party.quest.progress && user.party.quest.progress.up) {
            // might not be in a quest but want to know damage done to world boss
            questProgressUp = user.party.quest.progress.up;
        }
        if (user.party.quest.progress && user.party.quest.progress.collectedItems) {
            questProgressCollect = user.party.quest.progress.collectedItems;
        }
    }
    var customDayStart = user.preferences.dayStart || 0; // CDS
    var timezoneOffset = user.preferences.timezoneOffset || 0;

    // Find the correct date for "today". If the user has a CDS set, then
    // we need to subtract the CDS hour from the current date and time to
    // see if today is actually "yesterday". E.g., if the CDS is 5am, and
    // the user is using this tool at 4am on Monday, then the actual
    // "Habitica day" is Sunday (not Monday) because the CDS time has not
    // yet been reached; subtracting 5 hours from the current date and time
    // gives us yesterday's date. We then ignore the time portion of the
    // date because from now on we're comparing only days, not hours.
    var todayUser = moment().subtract(customDayStart, 'hours');
    todayUser = todayUser.startOf('day');

    var tavernBoss = tavern.quest && tavern.quest.active; // true/false

    var bossesLabel = '';
    var bossesWord  = 'boss';
    if (userIsOnBossQuest) {
        bossesLabel = 'your quest boss';
        if (tavernBoss) {
            bossesLabel += ' and ';
            bossesWord  += 'es';
        }
    }
    if (tavernBoss) {
        bossesLabel += 'the World boss';
    }

    // put the user's equipped battle gear into an object, with all
    // details about each piece:
    var equippedKeys = {};
    for (var i in user.items.gear.equipped) {
        var key = user.items.gear.equipped[i];
        equippedKeys[key] = content.gear.flat[key];
    }

    var computedStats        = computeStats(true);  // computed CON, INT, etc
    var computedStatsNoBuffs = computeStats(false); // ... without buffs
    // XXX_SOON god my computedStats code is just getting worse and worse

    // When calculating drop chance for a task, some of the user's stats
    // are used. We calculate those parts of the drop chance here since
    // they'll be identical for all tasks:
    var userStatsDropChance =
        (1 + (  computedStats.per                / 100)) *
        (1 + ( (user.contributor.level     || 0) / 40 )) *
        (1 + ( (user.achievements.rebirths || 0) / 20 )) *
        (1 + ( (user.achievements.streak   || 0) / 200));
    // console.log("computedStats.per: " + computedStats.per); // TST
    // console.log("userStatsDropChance: " + userStatsDropChance); // TST

    userDataInHeader();


    // create the content, section by section:
    //
    // TO ADD NEW SECTION: add a function here, OR add it within one of the
    // functions that is already here if appropriate for correct scoping
    // (e.g., features related to tasks should have their function put
    // inside collateAndDisplayTaskData):
    collateAndDisplayTaskData();
    dropCountAndCap();
    questProgress();
    analyseEquipment(); // missing gear, current gear, recommended gear
    subscriptionData();



    //////////////////////////////////////////////////////////////////////
    ////   Display the HTML that the functions have created   ////////////
    //////////////////////////////////////////////////////////////////////
    $('#loading .good').hide();
    //$('#documentationAndFormClose').show();
    //$('#documentationAndForm').hide();
    formatAndDisplayDASHBOARD();
    formatAndDisplayTOC();
    formatAndDisplayMAIN();

    $('[data-toggle="popover"]').popover({trigger:'hover focus click',html:true});
    // everything below here is functions used within this function


function formatAndDisplayDASHBOARD() {
    // TO ADD NEW SECTION: To create a dashboard tile (which is optional),
    // add the unique identifier for the new section to this array (the array
    // elements are in the order that the dashboard tiles appear on the page):
    var keys = ['currentHealth', 'dailiesIncomplete', 'damageToUser',
                'damageToParty', 'questProgress', 'questProgressSecond',
                'todosDated', 'dropsToday', 'sleeping'];
    var html = '<ul>';

    for (var i=0,ic=keys.length; i<ic; i++) {
        var data = DASHBOARD[keys[i]];
        if (! data) {
            continue;
        }
        var classes = (data.hidden) ? 'hide' : '';
        html += '<li ';
        if (data.id) {
            // id is needed only if other code will change tile background
            html += 'id="' + data.id + '" ';
        }
        html += 'title="' + data.hoverText + '" ';
        if (data.target) {
            html += 'data-target="' + data.target +
                    '" data-closemainsections="true" data-forceopen="true" ' +
                    'class="showHideToggle ' + classes + '"';
        }
        html += '><div class="' +
                data.status     + '"><div class="value">' +
                data.value      + '</div><div class="label">' +
                data.label      + '</div></div></li>';
    }


    html += '</ul><div class="clear"></div>';
    $('#DASHBOARD').html(html);
}


function formatAndDisplayTOC() {
    // TO ADD NEW SECTION: To create a Table of Content entry (required),
    // add the unique identifier for the new section to this array (the array
    // elements are in the order that the TOC links appear on the page):
    var keys = [
            'HEADING Tasks',
                'taskOverview', 'taskStatistics', 'untaggedTasks',
            // 'HEADING Habits',
                'habitTrends', 'habitHistory',
            'HEADING',
            // 'HEADING Dailies',
                'dailiesHistory', 'dailiesIncomplete',
            // 'HEADING To-Dos',
                'todosDated', 'todosCompleted',
            'HEADING Drops, Quests, Damage', 'dropsToday',
                'questProgress', 'damageDailies', 'statsAndStreaks',
            'HEADING Other',
                'missingEquipment',
                'currentGear', 'equipmentRecommendations', 'skillsAndBuffs',
                'subscriptionData'];
    var html = '';
    for (var i=0,ic=keys.length; i<ic; i++) {
        if (keys[i].match(/^HEADING/)) { // new section in Table of Contents
            var title = keys[i].replace(/^HEADING/, '');
            if (html) {
                html += '</ul></li>'; // close the previous section
            }
            html += '<li>' + title + (title ? ':' : '&nbsp;') + '<ul>';
        }
        else {
            var data = TOC[keys[i]];
            if (! data) {
                continue;
            }
            html += '<li class="showHideToggle" data-target="' +
                    data['target'] + '" data-closemainsections="true">' +
                    data['title']  + '</li>';
        }
    }
    html += '</ul></li></ul>'; // close the final section, and the parent ul
    $('#TOC').html('<ul id="tableOfContents">' + html +
                   '</ul><div class="clear"></div><hr class="padded" />');
}


function formatAndDisplayMAIN() {
    // TO ADD NEW SECTION: To make your new section appear on the page,
    // add the unique identifier for the new section to this array (the array
    // elements are in the order that the sections would appear on the page
    // if they were all visible at once):
    var keys = ['taskOverview', 'taskStatistics', 'untaggedTasks',
                'habitTrends', 'habitHistory', 'dailiesHistory', 'todosDated',
                'todosCompleted', 'dropsToday', 'questProgress',
                'damageDailies','dailiesIncomplete',//keep in that order
                'statsAndStreaks',
                'missingEquipment', 'currentGear', 'equipmentRecommendations',
                'skillsAndBuffs', 'subscriptionData'];
    var html = '';
    var functions = []; // functions to run after HTML code has been loaded
    for (var i=0,ic=keys.length; i<ic; i++) {
        var data = MAIN[keys[i]];
        if (! data) {
            continue;
        }
        html += '<div id="' +
                data.id     + '"><h2>' +
                data.title  + '</h2>' +
                data.html   +
                ((data.longContent) ? '<div class="mainSectionClose closer">' +
                                      'close / back to top</div>' : '') +
                '</div>';
        if (data['function']) {
            functions.push(data['function']);
        }
    }
    $('#MAIN').html(html);
    // execute any functions that need to be run AFTER the bulk of the
    // HTML has been created:
    $.each(functions, function(index,fn){
        fn();
    });
    if (sectionOpen && sectionOpen != 'documentationAndForm'
                    && sectionOpen != 'versionChanges'
    ) {
        // reopen the section that the user had open before re-fetching
        // data (except for sections that don't display the user's own data):
        $('#' + sectionOpen).show();
        openRelatedSections();
    }
}


function myDateConverter(date, style) { // XXX_SOON replace with moment
    if (typeof date === 'string' || typeof date === 'number') {
        date = new Date(date);
    }
    if (!date || isNaN(date.getTime())) {
        // Either the object that was passed in is not a Date object,
        // OR the date string that was passed in could not be converted
        // to a Date object, presumably because it's in a non-standard
        // format. We handle this by using today's date. It's a nasty
        // hack, but it's unlikely to occur, and no one's paying for
        // anything better.
        date = new Date();
    }

    if (style === 'XXX pretty') {
        // Format date as (weekday date month) and hh:mm:ss;
        // toDateString ordering might be locale-specific
        // var dateStr = date.toDateString().split(' ').slice(0,3).join(' ') +
        // ' ' + date.toTimeString().split(' ')[0];
        var dateStr = date.toLocaleString(undefined,
            { weekday: 'long', day: 'numeric', month: 'long',
              hour: '2-digit', minute: '2-digit' });
    }
    else {
        var y = date.getFullYear();
        var m = date.getMonth() + 1;
        var d = date.getDate();
        var H = date.getHours();
        var M = date.getMinutes();
        var S = date.getSeconds();
        var dateStr = y +
               '-' + (m<=9 ? '0'+m : m) +
               '-' + (d<=9 ? '0'+d : d);
        if (style === 'short') {
            dateStr = dateStr.replace(/^20/, ""); // remove century
        }
        if (style === 'long') {
            dateStr += ' ' + (H<=9 ? '0'+H : H) +
                       ':' + (M<=9 ? '0'+M : M) +
                       ':' + (S<=9 ? '0'+S : S);
        }
    }
    return dateStr;
}


function wiki(wikilink, pipelink) {
    // http://stackoverflow.com/a/1145525
    var wiki_link = wikilink.split(' ').join('_');
    return '<a href="http://habitica.wikia.com/wiki/' + wiki_link + '">' +
        ((typeof pipelink === "undefined") ? wikilink : pipelink) +
        '</a>';
}


openRelatedSections = function() {
    if ($('#damageDailiesSection').is(':visible')) {
        $('#dailiesIncompleteSection').show();
    }
    if ($('#dropsTodaySection').is(':visible')) {
        hideDropsInDashboard = false;
        $('#dropsTodayDashboard').show();
        // NOTE: We unhide the number of drops in the dashboard
        // only after the user has opened the main drops section,
        // because some users might prefer to not know (less
        // motivation if they know they've got all of today's drops).
        // BUT we do not reset the dashboard drops show/hide status
        // on re-fetch, because if the user wanted to see drops once,
        // they'll presumably want it again.
        if (userIsOnCollectionQuest) {
            // The user is on a collection quest and has viewed the
            // Drops Received Today section, so also show them the
            // Quest Progress section (collection quests have drops):
            $('#questProgressSection').show();
        }
    }
}


function pluralise(word, number) {
    var lcWord = word.toLowerCase();
    var needUpperCase = (lcWord == word) ? false : true;
    if (number != 1) {
        var pluralWords = {
            'has':   'have',
            'it':    'them',
            'this':  'these',
            'is':    'are',
            'daily': 'dailies',
            'Daily': 'Dailies',
        };
        if   (pluralWords[lcWord]) { word = pluralWords[lcWord]; }
        else                       { word += 's';    }
    }
    if (needUpperCase) { // must improve this if ever need ALL upper case
        word = upperCaseFirst(word);
    }
    return word;
}


function upperCaseFirst(word) {
    return word.charAt(0).toUpperCase() + word.slice(1);
}

function renderFormattedText(text, options) {
    function renderMarkdown(text) {
        text = markdown.render(text);
        if (options && options.removeParaTags) {
            text = String(text).replace(/^<p>|<\/p>\n$/g, '');
        }
        else if (options && options.setParaClass) {
            text = String(text).replace(/<p>/g,
                       '<p class="' + options.setParaClass + '">');
        }
        return text;
    }

    function renderEmoji(text) {
        //return emoji(text, '/js/emoji-images/pngs', 25);
        //return emoji(text,'https://s3.amazonaws.com/habitica-assets/cdn/emoji',25);
        var regex = /\:([a-z0-9\-_]+)\:/i;
        var url = 'https://s3.amazonaws.com/habitica-assets/cdn/emoji/';
        var matches = text.match(regex);
        var name = 0;
        var img = 0;

        if(matches)
        	name = matches[1].trim();
        if(name){
        	img = '<img class="emoji" src="'+url+name+'.png" height="25" />';
        	return text.replace(matches[0],img);
        }
        return text;
    }

    return renderEmoji(
        renderMarkdown(
            String(text).replace(/\&nbsp;/g, ' ')
        )
    );
}

function userDataInHeader() {
    var displayName = renderFormattedText(user.profile.name, {'removeParaTags':true});

    $('h1').append(displayName);
    $('#headerExtras').html(
            '<div id="explanationAndClearLinks">' +
            '<input id="refetch" type="submit" value="' +
            'Re-Fetch Data (last fetched ' + fetchtime + ')" /></div>'
    );
    $('#refetch').click(function(event){
        /* The user clicked on the Re-Fetch My Data button. */
        fetchData();
    });
}


function getCurrentHealth() {
    var health = Math.round(user.stats.hp * 10) / 10;
    // If the user's health is so low that it rounds to 0, then show
    // them a more-precise (hopefully non-zero) number, because 0
    // makes them wonder why they aren't dead:
    if (health == 0) {
        health = Math.round(user.stats.hp * 1000) / 1000;
        if (health == 0) {
            health = Math.round(user.stats.hp * 100000) / 100000;
        }
    }
    DASHBOARD.currentHealth = {'id': 'currentHealthDashboard',
        'label': 'Current Health', 'hoverText': 'your health',
        'value': health, 'status': 'neutral'};
    return health;
}


function collateAndDisplayTaskData() {
    // Set up data structures for storing task information:
    var taskOrder = 0; // default order of tasks in Habitica
    var allTasks = []; // except completed To-Dos
    var untaggedTasks = {'habits':[], 'dailies':[], 'todos':[], 'rewards':[]};
    var template = {'total':0, 'con':0, 'int':0, 'per':0, 'str':0};
    var countTasks = {
        'habits':          $.extend(true, {}, template),
        'dailiesDue':      $.extend(true, {}, template),
        'dailies':         $.extend(true, {}, template),
        'todosIncomplete': $.extend(true, {}, template),
        'todosComplete':   $.extend(true, {}, template),
        'todosAll':        $.extend(true, {}, template),
        'statsTotals':     $.extend(true, {}, template),
        'rewards':         {'total': 0}
    };
    var exampleTaskType  = '';    // Used to develop...
    var exampleAttribute = '';    // ... a useful customised example...
    var exampleFound     = false; // ... for the Task Statistics section.


    // Define some static stuff:
    var entityMap = {   "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': '&quot;',
                        "'": '&#39;',
                        "/": '&#x2F;'
                    };
    var colours = { 1: {'order':1, 'name':'Bright Blue',
                        'label':       '1) Bright Blue',
                        'nameNoSpace':    'BrightBlue',
                        'id':       'colourBrightBlue'
                       },
                    2: {'order':2, 'name':'Blue Grey',
                        'label':       '2) Blue Grey',
                        'nameNoSpace':    'BlueGrey',
                        'id':       'colourBlueGrey'
                       },
                    3: {'order':3, 'name':'Green',
                        'label':       '3) Green',
                        'nameNoSpace':    'Green',
                        'id':       'colourGreen'
                       },
                    4: {'order':4, 'name':'Yellow',
                        'label':       '4) Yellow',
                        'nameNoSpace':    'Yellow',
                        'id':       'colourYellow'
                       },
                    5: {'order':5, 'name':'Orange',
                        'label':       '5) Orange',
                        'nameNoSpace':    'Orange',
                        'id':       'colourOrange'
                       },
                    6: {'order':6, 'name':'Red',
                        'label':       '6) Red',
                        'nameNoSpace':    'Red',
                        'id':       'colourRed'
                       },
                    7: {'order':7, 'name':'Dark Red',
                        'label':       '8) Dark Red',
                        'nameNoSpace':    'DarkRed',
                        'id':       'colourDarkRed'
                       }
                  };


    // Get an array of all of the user's tags so that when we are
    // examining a task's tags, we can ignore any tags that don't appear
    // in that array (e.g., tags the user has deleted but that weren't
    // removed from the task).
    var knownTags = [];
    $.each(user.tags, function(index, obj){
        knownTags.push(obj.id);
    });

    var bluestTask   = {};
    var reddestTask  = {};
    var reddestHabit = {};
    var reddestDaily = {};
    var biggestTask  = {}; // task with greatest absolute magnitude
    var everyXDaysInUse = false;
    var habits   = collateHabitsData();  // populates the...
    var dailies  = collateDailiesData(); // ... function's "global" variables...
    var todosAll = collateTodosData();   // ... defined above...
    var rewards  = collateRewardsData(); // ......
    var todos          = todosAll[0];
    var todosCompleted = todosAll[1];

    // in case where the user has no tasks, or no tasks of a specific type:
    var nullTask = {text:'none', value:0, type:'habit', typePretty:'Habit'};
    if (typeof bluestTask.value === "undefined") {
        bluestTask   = $.extend({}, nullTask);
    }
    if (typeof reddestTask.value === "undefined") {
        reddestTask  = $.extend({}, nullTask);
    }
    if (typeof reddestHabit.value === "undefined") {
        reddestHabit = $.extend({}, nullTask);
    }
    if (typeof reddestDaily.value === "undefined") {
        reddestDaily = $.extend({}, nullTask);
        reddestDaily['type'] = 'daily';
        reddestDaily['typePretty'] = 'Daily';
    }
    if (typeof biggestTask.value === "undefined") {
        biggestTask  = $.extend({}, nullTask);
    }

    // TO ADD NEW SECTION: if the section is related specifically to tasks,
    // here is probably where you want to put its function.

    // display task data:
    taskOverview();
    taskStatistics();
    untaggedTasksSection();
    habitTrends();
    habitHistory();
    damageFromDailies();
    dailiesIncomplete();
    dailiesHistory();
    todosDated();
    todosCompletedTable();
    statsAndStreaks();
    skillsAndBuffs();

    function collateHabitsData() {
        var habits = [];
        $.each(user.habits, function(index, obj){
            modifyTaskProperties(obj);
            countTasks['habits']['total']++;
            countTasks['habits'][obj.attribute]++;
            countTasks['statsTotals'][obj.attribute]++;
            countTasks['statsTotals']['total']++;
            if (! exampleFound) {
                exampleTaskType  = 'habits';
                exampleAttribute = obj.attribute;
                if (obj.attribute != 'str') {
                    exampleFound = true; // We won't look for a better example
                    // later; we are happy with this one. We prefer to not use
                    // strength because a less-common attribute will probably
                    // provide a clearer example.
                }
            }
            habits.push(obj);
            allTasks.push(obj);
            if (! taskIsTagged(obj.tags)) {
                untaggedTasks['habits'].push(obj);
            }

            if (!obj.challenge || !obj.challenge.id) {
                if (typeof reddestHabit.value === "undefined" ||
                    obj.value < reddestHabit.value) {
                    reddestHabit = obj;
                }
                if (typeof reddestTask.value === "undefined" ||
                    obj.value < reddestTask.value) {
                    reddestTask = obj;
                }
                if (typeof bluestTask.value === "undefined" ||
                    obj.value > bluestTask.value) {
                    bluestTask = obj;
                }
                if (typeof biggestTask.value === "undefined" ||
                    Math.abs(obj.value) > Math.abs(biggestTask.value)) {
                    biggestTask = obj;
                }
            }
        });
        return habits;
    }


    function collateDailiesData() {
        var dailies = [];
        var valueMin = -47.27; // task values are capped ...
        var valueMax =  21.27; // ... for some purposes
        var conBonus = 1 - (computedStats['con'] / 250);
        if (conBonus < 0.1) { conBonus = 0.1; }
        var stealth = user.stats.buffs.stealth; // user avoids Dailies' damage
        $.each(user.dailys, function(index, obj){
            fixDailiesDefaults(obj);
            obj.dueToday = dailyIsDueToday(obj);
            modifyTaskProperties(obj);

            countTasks['dailies']['total']++;
            countTasks['dailies'][obj.attribute]++;
            countTasks['statsTotals'][obj.attribute]++;
            countTasks['statsTotals']['total']++;
            if (obj.dueToday) {
                countTasks['dailiesDue']['total']++;
                countTasks['dailiesDue'][obj.attribute]++;
            }
            if (! exampleFound) {
                if (obj.attribute != 'str') {
                    exampleTaskType  = 'dailies';
                    exampleAttribute = obj.attribute;
                    exampleFound     = true;
                }
                else {
                    exampleTaskType  = exampleTaskType  || 'dailies';
                    exampleAttribute = exampleAttribute || obj.attribute;
                }
            }

            obj.orderDailies = countTasks['dailies']['total'];

            if (obj.dueToday && !obj.completed && stealth > 0) {
                // user evades this daily
                stealth--;
                obj.stealthed = true;
            }

            // calculate damage this daily will do:
            if (sleeping || obj.completed || ! obj.dueToday || obj.stealthed) {
                obj.damageToUser           = 0;
                obj.damageToParty          = 0;
                obj.damageToPartyUnrounded = 0;
            }
            else {
                var currVal = obj.value; // task value
                if (currVal < valueMin) { currVal = valueMin; } // capped
                if (currVal > valueMax) { currVal = valueMax; } // capped
                var nextDelta = Math.abs(Math.pow(0.9747, currVal));
                var checklist = describeChecklist(obj);
                if (checklist.exists) {
                    nextDelta *= (1 - checklist.proportionDone);
                    // NOTE: If you tick off all the items in a Daily
                    // checklist but don't tick off the Daily itself,
                    // you take zero damage (confirmed by testing).
                }
                var delta = nextDelta; // Change this if we ever take
                                       // account of multiple missed days.
                if (quest.content && quest.content.boss) {
                    var bossDelta = delta;
                    if (obj.priority < 1) {
                        bossDelta *= obj.priority;
                    }
                    obj.damageToPartyUnrounded
                            = bossDelta * quest.content.boss.str;
                    obj.damageToParty
                            = Math.round(obj.damageToPartyUnrounded * 10) / 10;
                }
                else {
                    obj.damageToParty          = 0;
                    obj.damageToPartyUnrounded = 0;
                }
                var hpMod = delta * conBonus * obj.priority * 2;
                // priority is trivial (0.1), easy (1), medium (1.5), hard (2)
                obj.damageToUser = Math.round(hpMod * 10) / 10;
            }

            dailies.push(obj);
            allTasks.push(obj);
            if (! taskIsTagged(obj.tags)) {
                untaggedTasks['dailies'].push(obj);
            }
            if (!obj.challenge || !obj.challenge.id) {
                if (typeof reddestDaily.value === "undefined" ||
                    obj.value < reddestDaily.value) {
                    reddestDaily = obj;
                }
                if (typeof reddestTask.value === "undefined" ||
                    obj.value < reddestTask.value) {
                    reddestTask = obj;
                }
                if (typeof bluestTask.value === "undefined" ||
                    obj.value > bluestTask.value) {
                    bluestTask = obj;
                }
                if (typeof biggestTask.value === "undefined" ||
                Math.abs(obj.value) > Math.abs(biggestTask.value)) {
                    biggestTask = obj;
                }
            }
        });
        return dailies;


        function fixDailiesDefaults(task) {
            // Ensure that all repeat options make sense. At least one bug
            // can result in bad repeat options:
            // github.com/HabitRPG/habitrpg/issues/2334#issuecomment-66168155

            // EDIT: IGNORE THIS COMMENT FOR NOW:
            // If we find unexpected or missing repeat values, we set a flag
            // that causes the Daily to be treated as due (safer than treating
            // as not due - better to let the user think they will take more
            // damage than they actually do).
            //
            // EDIT: While the Habitica api.shouldDo code and this code are
            // being tweaked, we use the same behaviour here for Dailies that
            // have incorrect or missing options. I.e., we treat the Dailies
            // as not due because that is what Habitica does.

            // task.forceDue = false;
            task.forceNotDue = false;
            if (!task.frequency ||
                (task.frequency !== 'weekly' && task.frequency !== 'daily')) {
                task.frequency = 'weekly';
                // task.forceDue = true;
                task.forceNotDue = true;
            }
            if (task.frequency === 'weekly') { // Day of Week
                if (!task.repeat) {
                    task.repeat = { "su": true, "s": true, "f": true,
                         "th": true, "w": true, "t": true, "m": true };
                    // task.forceDue = true;
                    task.forceNotDue = true;
                }
            }
            else if (task.frequency === 'daily') { // Every X Days
                if (typeof task.everyX === 'undefined') { // can be zero
                    task.everyX = 1;
                    // task.forceDue = true;
                    task.forceNotDue = true;
                }
            }
            if (!task.startDate) {
                // This should not happen, but if it does, Habitica's code
                // treats it as starting on the day being examined (i.e., today
                // for the purposes of showing due Dailies). Hence we do the
                // same and we don't set forceDue.
                task.startDate = todayUser;
            }
        }

        function describeChecklist(task) {
            // Takes a task object. Returns an object describing aspects of the
            // task object's checklist (including whether it exists or not).
            if (! task.checklist || task.checklist.length == 0) {
                return {'exists': false};
            }
            var countDone = 0;
            $.each(task.checklist, function(index, obj){
                if (obj.completed == true) { countDone++; };
            });
            return {
                'exists': true,
                'proportionDone': (countDone / task.checklist.length),
                };
        }

        function dailyIsDueToday(task) { // ref: api.shouldDo
            // returns true if the Daily is due, false otherwise
            if (task.forceDue) {
                return true;
            }
            if (task.forceNotDue) {
                return false;
            }
            var startDate = moment(task.startDate).zone(timezoneOffset).startOf('day');
            if (startDate > todayUser) {
                return false;
            }

            if (task.frequency === 'weekly') { // Day of Week
                var dayname = ["su","m","t","w","th","f","s"][todayUser.day()];
                return task.repeat[dayname];
            }
            else if (task.frequency === 'daily') { // Every X Days
                if (task.everyX > 1) { // bug not relevant if due EVERY day
                    everyXDaysInUse = true;
                }
                var daysSinceTaskStart = todayUser.diff(startDate, 'days');
                return (daysSinceTaskStart % task.everyX == 0);
            }
        }
    }


    function collateTodosData() {
        var todos = [];
        var todosCompleted = [];
        $.each(user.todos, function(index, obj){
            modifyTaskProperties(obj);
            if (obj.completed == true) {
                countTasks['todosComplete']['total']++;
                countTasks['todosComplete'][obj.attribute]++;
                countTasks['statsTotals'][obj.attribute]++;
                countTasks['statsTotals']['total']++;
                countTasks['todosAll']['total']++;
                countTasks['todosAll'][obj.attribute]++;
                todosCompleted.push(obj);
            }
            else {
                countTasks['todosIncomplete']['total']++;
                countTasks['todosIncomplete'][obj.attribute]++;
                countTasks['statsTotals'][obj.attribute]++;
                countTasks['statsTotals']['total']++;
                countTasks['todosAll']['total']++;
                countTasks['todosAll'][obj.attribute]++;
                if (! exampleFound) {
                    if (obj.attribute != 'str') {
                        exampleTaskType  = 'todosIncomplete';
                        exampleAttribute = obj.attribute;
                        exampleFound     = true;
                    }
                    else {
                        exampleTaskType  = exampleTaskType  ||'todosIncomplete';
                        exampleAttribute = exampleAttribute || obj.attribute;
                    }
                }
                todos.push(obj);
                allTasks.push(obj);
                if (! taskIsTagged(obj.tags)) {
                    untaggedTasks['todos'].push(obj);
                }
            }
            if (!obj.challenge || !obj.challenge.id) {
                if (obj.completed == false) {
                    if (typeof reddestTask.value === "undefined" ||
                        obj.value < reddestTask.value) {
                        reddestTask = obj;
                    }
                    if (typeof bluestTask.value === "undefined" ||
                        obj.value > bluestTask.value) {
                        bluestTask = obj;
                    }
                    if (typeof biggestTask.value === "undefined" ||
                        Math.abs(obj.value) > Math.abs(biggestTask.value)) {
                        biggestTask = obj;
                    }
                }
            }
        });
        return [todos, todosCompleted];
    }


    function collateRewardsData() {
        var rewards = [];
        $.each(user.rewards, function(index, obj){
            modifyTaskProperties(obj);
            countTasks['rewards']['total']++;
            rewards.push(obj);
            if (! taskIsTagged(obj.tags)) {
                untaggedTasks['rewards'].push(obj);
            }
        });
        return rewards;
    }


    function modifyTaskProperties(obj) {
        obj.text  = renderFormattedText(obj.text, {'setParaClass':'taskName'});
        obj.notes = renderFormattedText(obj.notes,{'setParaClass':'taskNote'});
        obj.attributePretty = obj.attribute.toUpperCase();
        obj.typePretty   = upperCaseFirst(
                (obj.type == 'todo') ? 'To-Do' : obj.type );
        obj.valueRounded = Math.round(obj.value * 100) / 100;
        obj.magnitude    = Math.abs(obj.valueRounded);
        obj.order        = ++taskOrder;
        obj.creation     = reformatDate(obj.createdAt);
        obj.completion   = (obj.dateCompleted) ?
                           reformatDate(obj.dateCompleted) : {};
        obj.colour       = chooseColour(obj.value);
        obj.valueColourHtml = '<span class="coloured ' +
                              obj.colour.id + '">' +
                              obj.valueRounded + '<br />' +
                              obj.colour.nameNoSpace + '</span>';
        obj.difficulty = chooseDifficulty(obj.priority);
        obj.attributesHTML = '<div class="taskAttributes ' + obj.type + '">' +
                             attributesHTML() + '</div>';

        // compensate for bad history fields in Habits:
        if (obj.type === 'habit' && ! obj.history) {
            obj.history = [];
        }

        // calculate drop chance:
        if (obj.type === 'habit' && obj.up === false) {
            obj.dropChance = 0; // no drops from habits with + button disabled
        }
        else {
            var tempValue = Math.abs(obj.value - 21.27);
            if (tempValue > 37.5) tempValue = 37.5;
            var checklistChance = 0; //(_.reduce(obj.checklist, (function(m, i) {
                        // return m + (i.completed ? 1 : 0);
                      // }), 0) || 0); // XXX_SOON finish this
            var chance = tempValue / 150 + .02;
            chance *= obj.priority *
                      (1 + ((obj.streak || 0) / 100)) *
                      userStatsDropChance *
                      (1 + .5 * checklistChance);
            // var chanceBefore = Math.round(chance * 100); // TST
            chance = diminishingReturns(chance, 0.75);
            obj.dropChance = Math.round(chance * 100) + '%';
                    // + ' (' + chanceBefore + ' %)'; // TST
            // drop chance is 0 for negative habits
        }

        function reformatDate(dateString) {
            var formattedDate = myDateConverter(dateString, 'long');
            var shortDate     = myDateConverter(dateString, 'short');
            return { 'dateAndTime': formattedDate,
                     'shortDate': shortDate };
        }

        function chooseColour(value) {
            // from http://habitica.wikia.com/wiki/Task_Value :
            // Bright Blue  Greater than 10
            // Blue Grey    Between 5 and 10
            // Green        Between 1 and 5
            // Yellow       Between -1 and 1
            // Orange       Between -10 and -1
            // Red          Between -20 and -10
            // Dark Red     Less than -20
            if      (value < -20){ return colours[7]; }
            else if (value < -10){ return colours[6]; }
            else if (value <  -1){ return colours[5]; }
            else if (value <   1){ return colours[4]; }
            else if (value <   5){ return colours[3]; }
            else if (value <  10){ return colours[2]; }
            else                 { return colours[1]; }
        }

        function chooseDifficulty(value) {
            if      (value == 0.1){ return 'trivial'; }
            else if (value == 1  ){ return 'easy'; }
            else if (value == 1.5){ return 'medium'; }
            else if (value == 2  ){ return 'hard'; }
            else                  { return 'unknown (' + value + ')'; }
        }

        function attributesHTML() {
            if (obj.type == 'habit') {
                return taskPartHTML(obj.up, '+') +
                       taskPartHTML(obj.down, '&ndash;');
            }
            else if (obj.type == 'daily') {
                var startDateDescription = '';
                if (moment(obj.startDate).isAfter(todayUser)) {
                    startDateDescription = '<br style="line-height:150%;" />' +
                            taskPartHTML(obj.dueToday, 'starts ' +
                                moment(obj.startDate).format('YYYY-MM-DD'),
                                true);
                }
                if (obj.frequency === 'weekly') {
                    return taskPartHTML(obj.repeat['su'], 'Su') +
                           taskPartHTML(obj.repeat['m' ], 'Mo') +
                           taskPartHTML(obj.repeat['t' ], 'Tu') +
                           taskPartHTML(obj.repeat['w' ], 'We') +
                           taskPartHTML(obj.repeat['th'], 'Th') +
                           taskPartHTML(obj.repeat['f' ], 'Fr') +
                           taskPartHTML(obj.repeat['s' ], 'Sa') +
                           startDateDescription;
                }
                else if (obj.frequency === 'daily') {
                    return taskPartHTML(obj.dueToday,
                            'every ' + obj.everyX + ' days') +
                            startDateDescription;
                }
            }
            else if (obj.type == 'todo') {
                return obj.date == null ?
                       '<span class="attributeOff">(no date)</span>' :
                       obj.date.substr(0, 10);
            }
            else {
                return '';
            }
        }

        function taskPartHTML(val, txt) {
            return ' <span class="' +
                   (val ? 'attributeOn' : 'attributeOff') + '">' +
                   txt + '</span>';
        }
    }


    function taskIsTagged(tagObj) { // returns true if tagged, false otherwise
        tagFound = false; // we have not yet found any valid tags for this task
        if (tagObj) {
            $.each(tagObj, function(index, tagId){
                if ($.inArray(tagId, knownTags) >= 0) {
                    tagFound = true;
                    return false; // break out of the loop
                }
            });
        }
        return tagFound;
    }


    function taskOverview() { // Displays all tasks of all kinds.
        // Also shows one random To-Do:
        var randomTodoHtml = '';
        if (todos.length > 0) {
            var randomTodo = todos[Math.floor(Math.random() * todos.length)];
            randomTodoHtml = '<h3>Random To-Do</h3><p>' +
                             randomTodo.text + '</p>';
        }

        var title   = 'Task Overview';
        var id      = 'taskOverviewSection';
        var orderId =  'taskOverview';
        TOC[orderId]  = {'target': id, 'title':  title};
        MAIN[orderId] = {'id': id, 'title': title, 'longContent': true,
                   'function': createTaskOverviewTable,
                   'html':
                    /*
                    '<div id="taskOverviewExplanationToggle" class="showHideToggle" data-target="taskOverviewExplanation" data-linktext="explanation">show explanation</div>' +
                    '<div id="taskOverviewExplanation" class="hide">' +
                    '   <p class="lowlight">NOTE: This feature contains advanced JavaScript and layout options which will probably perform differently in different browsers. If you experience problems, ' + tellMe + '.</p><p>The table below shows your tasks (Habits, Dailies, and To-Dos), with their ' + wiki('Advanced Options', 'attributes') + ' and ' + wiki('Task Value', 'colours, values, and magnitudes') + ' (value and magnitude are useful for choosing tasks to cast skills on). Completed To-Dos are not shown; completed Dailies are.</p><ul class="padded"><li><span class="subheading">Sorting:</span> Click on a column heading to sort the table by that column. Then, hold down your shift key and click on other column headings for a multi-column sort. The starting sort order is the order of your tasks in Habitica.</li><li><span class="subheading">Filtering:</span> Use the drop-down menus ("type", "attr.", "colour") to filter the list. Select multiple items from one menu to filter for tasks matching <span class="highlight">any</span> of those items (widen the filter). Select items from a different menu to narrow the filter. Click on the blue links that you\'ll see after you\'ve chosen a filter to remove that filter.</li><li><span class="subheading">Searching:</span> Type words in the search box to show only tasks containing all of those words. This is <span class="highlight">not</span> just for task titles; you can search on any field. The words do not have to be consecutive. Examples:<ul><li>Search for "car wash" to find the task "wash the car"</li><li>Search for "balloon habit" to find all Habits that contain the word "balloon".</li><li>Search for "14-01-30" (or "2014-01-30" or "01-30") to find tasks created on that day.</li></ul></li><li><span class="subheading">What dark magic is this?</span> <a href="http://datatables.net/">Data Tables</a> (a plug-in for jQuery, which adds advanced interaction controls to any HTML table). <a href="http://legacy.datatables.net/extras/thirdparty/ColumnFilterWidgets/DataTables/extras/ColumnFilterWidgets/">ColumnFilterWidgets</a> (an add-on for DataTables, which creates filtering widgets based on the data in table columns).</li></ul><p>Underneath this table, you will find one randomly-selected item from your To-Do list. Re-fetch your data to see a different random To-Do.</p>' +
                    '   <div class="showHideToggle closer" data-target="taskOverviewExplanation" data-resettoggletext="taskOverviewExplanationToggle">hide explanation</div>' +
                    '</div>' +
                    '<div id="taskOverviewDeveloperDataToggle" class="showHideToggleClass" title="show/hide task IDs and createdAt strings">toggle developer data</div>' + */
                    '<table></table>' +
                    randomTodoHtml
        };

        function createTaskOverviewTable() {
            // Use DataTables to build the table (the table tag must be
            // visible first for layout to be correct):
            $('#taskOverviewSection').show();
            $('#taskOverviewSection table').dataTable({
                'aaData': allTasks,
                'aoColumns': [
            { 'mData' : 'order', // needed to ensure correct starting sort
              'sTitle': '#',    'bVisible': false,
            },
            { 'mData' : 'typePretty', 'sClass': 'center',
              'sTitle': 'type',       'sWidth': '10%',
            },
            { 'mData' : 'attributePretty',  'sClass': 'center',
              'sTitle': 'attr.',      'sWidth': '10%',
            },
            { 'sTitle': 'difficulty',  'sClass': 'center', 'bVisible': false,
              'mData' : function ( source, type, val ) {
                // exclusively for 'oColumnFilterWidgets' drop-down menu
                // filtering, not displayed in table
                return source.priority + ') ' + source.difficulty;
               }
            },
            { 'sTitle': 'difficulty', 'sClass': 'center', 'sWidth': '10%',
              'mData': function ( source, type, val ) {
                if (type === 'set') {
                  return; // http://datatables.net/ref#mData
                }
                else if (type === 'display') {
                  return source.difficulty;
                }
                return source.priority;
                // NB: previous column does drop-down filtering for difficulty
              }
            },
            { 'mData' : 'colour.label',
              'sTitle': 'colour',     'sClass': 'center', 'bVisible': false,
            },
            { 'sTitle': 'value',      'sClass': 'center', 'sWidth': '10%',
              'mData': function ( source, type, val ) {
                if (type === 'set') {
                  return; // http://datatables.net/ref#mData
                }
                else if (type === 'display') {
                  return source.valueColourHtml;
                }
                else if (type === 'filter') {
                  return source.colour.name;
                }
                // 'sort', 'type' and undefined all just use the integer
                return source.value;
              }
            },
            { 'mData' : 'magnitude', 'sClass': 'center', 'sWidth': '10%',
               'asSorting': ['desc','asc'],
              'sTitle': '<abbr title="magnitude (the value, but with negative'
                        + ' signs removed)">mag.</abbr>',
            },
            // { 'mData' : 'dropChance', 'sClass': 'center', 'sWidth': '10%',
               // 'asSorting': ['desc','asc'], // XXX ?
              // 'sTitle': 'drop chance'
            // },
            { 'sTitle': '<abbr title="creation date">added</abbr>',
              'sClass': 'center',       'sWidth': '10%',
              'asSorting': ['desc','asc'],
              'mData': function ( source, type, val ) {
                if (type === 'set') {
                  return;
                }
                else if (type === 'display') {
                  return '<abbr title="' +
                         source.creation.dateAndTime + '">' +
                         source.creation.shortDate +
                         '</abbr><span class="developerData"><br />' +
                         source.createdAt + '</span>';
                }
                else if (type === 'filter') {
                  return source.creation.dateAndTime;
                }
                return source.creation.dateAndTime;
              }
            },
            { 'sTitle': 'task',       'sWidth': '*',
              'mData': function ( source, type, val ) {
                if (type === 'set') {
                  return;
                }
                else if (type === 'display') {
                  return '<span class="task-notes" data-toggle="popover" data-placement="bottom" data-trigger="focus" data-content="'+source.notes+'">'
                          + source.text + '</span>';
                        /* +
                         '<span class="developerData"><br />' +
                         source._id +
                         (source.legacyId ? '<br />legacyId: ' +
                          source.legacyId : '') +
                         '</span>' +
                         source.attributesHTML;
                        */
                }
                else if (type === 'filter') {
                  return source.text;
                }
                return source.text;
                // this routine made a lot more sense when I was
                // experimenting with different text for
                // display, filter, sort
              }
            },
            // For putting extra data in a separate column:
            // { 'sTitle': 'id',    'bVisible': true, 'sWidth': '10%',
              // 'sClass': 'developerData',
              // 'mData': 'id',
            // },
                ],
                // 'scrollY': 300,
                // 'bInfo': false,
                // 'sDom': 'W<"clear"><"top"if>rt<"bottom"iflp><"clear">',
                'sDom': 'W<"clear"><"top"if>rt<"bottom"><"clear">',
                'bAutoWidth': false,
                'bPaginate': false,
                'bDeferRender': true,
                // 'bSortClasses': false,
                "sScrollX": "100%",
                // "sScrollXInner": "200%",
                "bDestroy": true, // allows table to recreate on refetch
                'oColumnFilterWidgets': {
                    'aiExclude': [ 0, 4, 6, 7, 8, 9 ],
                    // For including drop-chance column:
                    // 'aiExclude': [ 0, 4, 6, 7, 8, 9, 10 ],
                }
            });
            $('#taskOverviewSection').hide();
            // Hide developer data
            $('#taskOverviewSection .developerData').hide();
            $('#taskOverviewSection .showHideToggleClass').on('click', function (e) {
                e.preventDefault();
                $('#taskOverviewSection .developerData').toggle();
            });
            return;
        }
    }


    function taskStatistics() {
        var title = 'Task Statistics';
        var html = '<p>This table shows the number of tasks you have ' +
            'for each kind of task (Habits, Dailies, To-Dos) ' +
            'and the number of tasks assigned to each ' +
            wiki('Character Attributes', 'attribute') + '.';
        if (exampleTaskType && exampleAttribute) {
            html += ' For example, you have ' +
                    countTasks[exampleTaskType]['total'] + ' ' +
                    ((exampleTaskType == 'todosIncomplete')
                                ? 'incomplete to-dos' : exampleTaskType);
            if (countTasks[exampleTaskType]['total']
                    == countTasks[exampleTaskType][exampleAttribute]) {
                html += ' and all have';
            }
            else {
                html += ' of which ' +
                        countTasks[exampleTaskType][exampleAttribute] +
                        ' ' +
                        pluralise('has',
                            countTasks[exampleTaskType][exampleAttribute]);
            }
            html += ' been assigned to ' +
                    exampleAttribute.toUpperCase() + '.';
        }
        html += ' Note that attributes on tasks are only relevant if you ' +
            'have task-based ' + wiki('Automatic Allocation')
            + ' turned on.</p>' +
            '<table><tr>' +
            '<th>Attribute</th><th>Habits</th>' +
            '<th>Dailies - Due</th><th>Dailies - All</th>' +
            '<th>To-Dos - Incomplete</th><th>To-Dos - Complete *</th>' +
            '<th>To-Dos - All</th><th>Total Tasks for each Attribute</th>' +
            '</tr>';
        $.each(['con','int','per','str','total'], function(index, attr){
            html += '<tr' +
                    ((attr == 'total') ? ' class="total"' : '') +
                    '><td>' +
                    ((attr.length==3) ? attr.toUpperCase()
                                      : upperCaseFirst(attr))
                    '</td>';
            $.each(['habits','dailiesDue','dailies',
                    'todosIncomplete','todosComplete','todosAll',
                    'statsTotals'], function(index, type){
                html += '<td>' + countTasks[type][attr] + '</td>';
            });
            html += '</tr>';
        });
        html += '</table>' +
            '<p class="lowlight"><strong>*</strong> Your completed To-Dos ' +
            'are automatically archived after three days to improve ' +
            'Habitica\'s speed and so most of them cannot be seen in ' +
            'Habitica. However, they can be exported using the ' +
            wiki('Data Export', '"User Data" export option') +
            '. This total number of completed ' +
            'To-Dos includes those archived ones.</p>' +
            '<p style="margin-top:2em">You have <span class="highlight"> ' +
            countTasks['rewards']['total'] + ' ' +
            pluralise('Reward', countTasks['rewards']['total']) +
            '</span>.</p>';

        // Training Points:
        if (user.preferences.automaticAllocation &&
            user.preferences.allocationMode == 'taskbased'
           ) {
            title += ' and Training Points';
            html += '<h3>Training Points</h3>' +
                '<p>When you use task-based ' +
                wiki('Automatic Allocation', 'auto-allocation') +
                ' you gain and lose points of training for the ' +
                wiki('Character Attributes', 'attributes') +
                ' you\'ve assigned to your tasks. When you ' +
                'level up, the attribute with the most training gets a ' +
                'point assigned, and all training resets to 0 for the ' +
                'next level. Your current training points are:</p>' +
                '<table>';
            $.each(user.stats.training, function(key, value){
                value = Math.round(value * 10) / 10;
                html += '<tr><td>' +
                        key.toUpperCase() + '</td><td>' +
                        value + '</td></tr>';
            });
            html += '</table>';
        }

        var id      = 'taskStatisticsSection';
        var orderId = 'taskStatistics';
        TOC[orderId]  = {'target': id, 'title':  title};
        MAIN[orderId] = {'id': id, 'title': title, 'html': html};
    }


    function untaggedTasksSection() {
        var html = formatUntaggedTasks('Habits',  untaggedTasks['habits' ]) +
                   formatUntaggedTasks('Dailies', untaggedTasks['dailies']) +
                   formatUntaggedTasks('To-Dos',  untaggedTasks['todos'  ]) +
                   formatUntaggedTasks('Rewards', untaggedTasks['rewards']);
        if (! html) {
            return;
        }
        var id    = 'untaggedTasksSection';
        var title = 'Tasks Untagged';
        var orderId = 'untaggedTasks';
        TOC[orderId] = {'target': id, 'title':  title};
        MAIN[orderId] = {'id': id, 'title': title, 'longContent': true,
            'html': html};
        function formatUntaggedTasks(title, tasks) {
            var html = '';
            $.each(tasks, function(index, obj){
                html += '<li>' + obj.text + '</li>';
            });
            if (html) {
                return '<h3>' + title + '</h3><ul>\n' + html + '</ul>';
            }
            else {
                return '';
            }
        }
    }

    function habitTrends() {
        var html = '<p>The chart below provides a visual representation of the trends in your Habits as reflected by the data recorded in Habitica. Here you can get an idea of which Habits you are reinforcing, and which are being neglected. The data provided to this chart is the same as displayed in the Habit History section, limited to the last 500 entries. The Habit History section only records when a change occurs in a Habit, while the trend chart includes the values for all Habits every day, regardless if they changed.</p>';
        html += '<p>This chart is interactive, and exposes multiple controls:<ul><li>Scroll inside the chart to <strong>zoom</strong></li><li>Click and drag (left/right) to <strong>slide</strong> along the time-axis when zoomed in</li><li><strong>Hover</strong> over a datapoint to see all the values for that day</li><li>Click the Habits in the <strong>legend</strong> to toggle their display in the chart on/off</li></ul></p>';
        html += '<button onclick="$(\'.legend-toggle\').length != 0 ? $(\'.legend-toggle\').click() : $(\'.legend span\').click();" title="This may take a few seconds with a large amount of data">Toggle All</button>';
        var habitNames = habits.reduce(function(names, item) {
             names.push(item.text);
             return names;
        }, []);
        // see reported issue for limit of ~500 elements prior to performance degradation
        // https://github.com/masayuki0812/c3/issues/172
        var limit = habitNames.length == 0 ? 0 : Math.floor(500 / habitNames.length);
        var habitTimeData = extractHabitTimeData(limit);

        html += '<div class="habit-chart-container"><div id="habit-chart"></div></div><ul>';
        var createHabitChart = function createHabitChart() {
            habitChart = c3.generate({
                bindto: '#habit-chart',
                data: {
                    x: 'timeline',
                    xFormat: '%a, %b %d %Y',
                    columns: habitTimeData,
                    type: 'area-spline'
                },
                axis: {
                    x: {
                        type: 'timeseries',
                        tick: {
                            format: '%a, %b %d %Y'
                        }
                    }
                },
                zoom: {
                    enabled: true
                },
                legend: {
                    show: false
                },
                point: {
                    r: 0,
                    focus: {
                        expand: {
                            r: 4
                        }
                    }
                },
                tooltip: {
                    format: {
                        value: function (value, ratio, id, index) {
                            return value.toFixed(2);
                        }
                    }
                }
            });
            d3.select('.habit-chart-container').insert('div').attr('class', 'legend').selectAll('span')
                .data(habitNames)
                .enter().append('span')
                .attr('data-id', function (id) { return id; })
                .html(function (id) { return id; })
                .each(function (id) {
                    d3.select(this).style('background-color', habitChart.color(id));
                    d3.select(this).style('border-radius', '.5em');
                    d3.select(this).style('padding', '.5em');
                    d3.select(this).style('margin', '.25em');
                    d3.select(this).style('height', '2em');
                    d3.select(this).style('cursor', 'pointer');
                    d3.select(this).style('display','inline-table');
                })
                .on('mouseover', function (id) {
                    habitChart.focus(id);
                })
                .on('mouseout', function (id) {
                    habitChart.revert();
                })
                .on('click', function (id) {
                    habitChart.toggle(id);
                    $(this).toggleClass('legend-toggle');
                });
        }

        var id      = 'habitTrendsSection';
        var title   = 'Habit Trends';
        var orderId = 'habitTrends';
        TOC[orderId]  = {'target': id, 'title':  title};
        MAIN[orderId] = {'id': id, 'title': title, 'html': html, 'function': createHabitChart};

        function extractHabitTimeData(limit) {
            var timeline = collectTimelineDays(habits);
            var habitTimeData = habits.reduce(function(habitRows, habit) {
                var habitRow = [];
                $.each(timeline, function(key, date) {
                    habitRow.push(getValueOfTaskByDay(habit, date.toDateString(), habitRow[habitRow.length - 1] || 0));
                });
                habitRow.splice(0, habitRow.length - limit);
                habitRow.unshift(habit.text);
                habitRows.push(habitRow);
                return habitRows;
            }, []);
            timeline.splice(0, timeline.length - limit);
            timeline.unshift('timeline');
            habitTimeData.unshift(timeline);

            return habitTimeData;
        }

        // Collect a unique array of all the dates from all the histories in asc order.
        // Used to lay out time for charts, the date granularity is limited to a single day.
        function collectTimelineDays(data) {
            return [].reduce.call(data, function(carry, item) {
                if (item.hasOwnProperty('history')) return carry.concat(collectDaysFromSingleTaskHistory(item));
                return carry;
            }, []).filter(function(date, index, self) {
                return self.indexOf(date) === index;  // this reduces it to a unique list
            }).map(function(dateString) {
                return new Date(dateString);
            }).sort(function(a,b) {
                return a - b;  // and puts it in ascending order
            });
        }

        function collectDaysFromSingleTaskHistory(task) {
            return task.history.reduce(function(dates, historical_item) {
                dates.push(formatDayDate(historical_item));
                return dates;
            }, [])
        }

        // If there are multiple values for a day, we grab the last entry we see.
        // Use the most recent value if none is available for that day.
        function getValueOfTaskByDay(task, day, prev) {
            return task.history.reduce(function(task_value, historical_item) {
                var historical_date = formatDayDate(historical_item);
                if (historical_date == day) {
                    return historical_item.value;
                }
                return task_value;
            }, decayPreviousValue(prev));
        }

        // Habits which are not reinforced decay over time.
        // Decay factor taken from Habitica common/script/index.coffee
        function decayPreviousValue(prev) {
            return Math.abs(prev) < 0.1 ? 0 : prev * 0.5;
        }

        // Use dateStrings to make filtering to a unique list easier later
        function formatDayDate(historical_item) {
            return (new Date(historical_item.date)).toDateString()
        }
    }

    function habitHistory() {
        var html = '<p class="narrowContent">This shows your Habits and <strong>some</strong> of the dates and times you clicked on them; there is <a href="https://github.com/HabitRPG/habitrpg/issues/3079">an issue</a> which prevents Habitica from showing all of your clicks. <!-- IF THE ISSUE GOES AWAY: ... and the dates and times they were marked <span class="buttonUsed">up</span> (+ button) or <span class="buttonUsed">down</span> (- button). It does not include any archived history data that might have been saved for your account, so it contains only recent data. For up-and-down Habits (where both + and - are active), most of the data points are marked with <span class="buttonUsed">up</span> or <span class="buttonUsed">down</span>, but for the oldest data point, it is not possible to tell whether + or - had been hit. --> Habits with no history are highlighted in bold, in case you would like to consider them for greater focus.</p><ul>';
        $.each(habits, function(index, obj){
            html += collateHistoryForOneHabit(obj);
        });
        html += '</ul>';
        var id      = 'habitHistorySection';
        var title   = 'Habit History';
        var orderId = 'habitHistory';
        TOC[orderId]  = {'target': id, 'title':  title};
        MAIN[orderId] = {'id': id, 'title': title, 'longContent': true,
                         'html': html};

        function collateHistoryForOneHabit(obj) {
            //// The commented out code below is only useful if ALL recent
            //// habit clicks are recorded in the user's data.
            //// Currently they are not:
            ////    https://github.com/HabitRPG/habitrpg/issues/3079
            ////    "habit history condenses current day's data"

            //// var canDoDown = obj.down;
            //// var canDoUp   = obj.up;
            //// var canDoBoth = canDoDown && canDoUp;

            // Here we take each history item, convert its date to a
            // standard format (my histories have varying formats,
            // presumably from different apps I've used), and store
            // it in an array; then we sort the array by date:
            var historyItems = [];
            $.each(obj.history, function(index, histObj){
                var value = histObj.value;
                var date = new Date(histObj.date);
                historyItems.push({"date":date, "value":value});
            });
            historyItems.sort(function(a,b) {
                return a.date - b.date;
            });

            //// var previousValue; // used to work out if user hit + or -
            var historyList = [];
            $.each(historyItems, function(index, histObj){
                var value = histObj.value;
                var date  = myDateConverter(histObj.date, 'long');
                //// var buttonUsed = '?up/down?'; // default value
                //// if (canDoBoth) {
                    //// if (previousValue != undefined) {
                        //// buttonUsed = (value > previousValue) ? 'up':'down';
                    //// }
                //// }
                //// else {
                    //// buttonUsed = (canDoUp) ? 'up' : 'down';
                //// }
                value = Math.round(value * 100) / 100;
                historyList.push('<li>'
                        + date
                        //// + ': ' + ' <span class="buttonUsed">'
                        //// + buttonUsed
                        //// + '</span>'
                        + ' <span class="historyValue">(value: '
                        + value + ')</span>'
                        + '</li>');
                //// previousValue = value;
            });
            var habitText = obj.text;
            var noHistoryClass = '';
            if (historyList.length == 0) {
                noHistoryClass = 'noHistory';
                habitText += ' <span>(no history)</span>';
            }
            else {
                historyList.reverse(); // put most recent at top; we couldn't
                       // do this earlier when we sorted the items because the
                       // 'buttonUsed' code needed them in chronological order
                habitText += '<ul class="padded">' +
                           historyList.join('') + '</ul>';
            }
            return '<li class="' + noHistoryClass + '">' + habitText + '</li>';
        }
    }


    function damageFromDailies() {
        var id      = 'damageDailiesSection';
        var title   = 'Damage from Dailies';
        var orderId = 'damageDailies';
        var html = '';
        var modifyHealthDashboardTile = false;
        if (sleeping) {
            html += '<p>You are ' +
                    wiki('Tavern', 'resting in the inn') +
                    ' so you will not take any damage from your' +
                    ' uncompleted Dailies.</p>';
            if (quest.content && quest.content.boss) {
                html += '<p> However, you are also on a ' +
                        wiki('Boss', 'boss') + ' ' +
                        wiki('Quests', 'quest') +
                        ' so you <span class="highlight">will</span> still' +
                        ' take damage from the uncompleted Dailies of other' +
                        ' quest participants.</p>';
            }
        }
        else {
            html += '<p class="lowlight">Be cautious about using this to prevent death! &nbsp; <span id="damageDailiesExplanationToggle" class="showHideToggle" data-target="damageDailiesExplanation" data-linktext="explanation">show explanation</span></p><ul id="damageDailiesExplanation" class="padded hide"><li>These estimates have been accurate during testing but your usage of Habitica might involve factors that were not considered, and so this information cannot be guaranteed to be correct.</li><li>If your health is low, it is wise to protect yourself from death even if these estimates indicate that you will not die.</li><li>If you have not logged in to Habitica for more than a day, the damage that you (and your fellow quest participants) will take will be <span class="highlight">much greater</span> than shown here.</li><li class="showHideToggle lowlight" data-target="damageDailiesExplanation" data-resettoggletext="damageDailiesExplanationToggle" style="list-style-type: none; padding: 8px 0 20px 0">hide explanation</li></ul>';
            var damageToUser  = 0;
            var damageToParty = 0;
            $.each(dailies, function(index, obj){
                damageToUser  += obj.damageToUser; // H'RPG uses rounded value
                damageToParty += obj.damageToPartyUnrounded;
            });
            var damageTotal = Math.ceil((damageToUser + damageToParty)*10)/10;
            damageToUser    = Math.ceil(damageToUser  * 10) / 10;
            damageToParty   = Math.ceil(damageToParty * 10) / 10;
            // We round UP with ceil because we must never let the user
            // think they will take even slightly less damage than they really
            // will. Imagine if they died from an extra 0.1 damage that this
            // page didn't tell them they had!
            if (quest.content && quest.content.boss) {
                if (damageToUser == 0) {
                    html += '<p>You and your fellow ' +
                        wiki('Quests', 'quest') +
                        ' participants will take an ' +
                        '<span class="highlight">estimated 0</span> damage ' +
                        'from your own Dailies.</p><p>However you ' +
                        '<span class="highlight">will</span> still take ' +
                        'damage from the uncompleted Dailies of other quest ' +
                        'participants.</p>';
                }
                else {
                    html += '<p>If you do no more Dailies today, you will ' +
                        'take an <span class="highlight">estimated ' +
                        damageToUser +
                        '</span> damage from your Dailies directly.</p>' +
                        '<p>In addition, you are on a ' +
                        wiki('Quests', 'quest') + ', so the ' +
                        wiki('Boss', 'boss') +
                        ' will inflict an <span class="highlight">estimated ' +
                        damageToParty +
                        '</span> damage to you and to your fellow quest ' +
                        'participants because of your uncompleted Dailies.' +
                        '</p><p>Thus your total damage due to your own ' +
                        'uncompleted Dailies will be ' +
                        '<span class="highlight">approximately ' +
                        damageTotal + '</span>. ' +
                        'Your current health is <span class="highlight">' +
                        health +
                        '</span>.</p>' +
                        '<p>You will also take damage from the uncompleted' +
                        ' Dailies of other quest participants.</p>';
                }
            }
            else {
                html += '<p>If you do no more Dailies today, you will take ' +
                    'an <span class="highlight">estimated ' +
                    damageToUser +
                    '</span> damage. Your current health is ' +
                    '<span class="highlight">' +
                    health +
                    '</span>.</p>';
            }
            if (damageTotal >= health) {
                // make the Current Health dashboard tile
                // turn red when your health is too low
                modifyHealthDashboardTile = function(){
                    $('#currentHealthDashboard > div')
                            .removeClass('neutral').addClass('danger');};
            }
        }
        TOC[orderId]  = {'target': id, 'title':  title};
        MAIN[orderId] = {'id': id, 'title': title, 'html': html,
                         'function': modifyHealthDashboardTile };

        if (sleeping) {
            DASHBOARD.sleeping = {'label': '',
                'hoverText': 'You are resting in the inn. Go to the ' +
                         'Social page to check out of the inn.',
                'target': id, 'value': 'Zz<sub>zZzz<sub>zz</sub></sub>',
                'status': 'safe'};
        }
        else {
            var questMsg = (quest.content && quest.content.boss) ?
                           'AND from your quest boss due to those Dailies ' :
                           '';
            DASHBOARD.damageToUser = {'label': 'Est. Damage to You',
                'hoverText': 'health loss you will take overnight from your ' +
                         'uncompleted Dailies ' +
                         questMsg + '(click for more information)',
                'target': id, 'value': damageTotal,
                'status': ((damageToUser) ? 'danger' : 'safe')
                };
            if (quest.content && quest.content.boss) {
                var label = 'Est. Damage to Party';
                if (userId == '3e595299-3d8a-4a10-bfe0-88f555e4aa0c' ||
                    userId == 'e7b5d1e2-3b6e-4192-b867-8bafdb03eeec'    // Ryan
                ) {
                    label = 'Est.Dam.2Part. :P';
                }
                DASHBOARD.damageToParty = {'label': label,
                    'hoverText': 'health loss your party will take ' +
                         'overnight from your quest boss due to your own ' +
                         'uncompleted Dailies (click for more information)',
                    'target': id, 'value': damageToParty,
                    'status': ((damageToParty) ? 'danger' : 'safe')
                    };
            }
        }
    }


    function dailiesIncomplete() {
        var id      = 'dailiesIncompleteSection';
        var title   = 'Dailies Incomplete';
        var orderId = 'dailiesIncomplete';
        // sectionOpen = id; // TST

        if (sleeping) {
            return; // can't do Dailies while resting in inn
        }
        var dailiesIncomplete     = [];
        var dailiesIncompleteGrey = [];
        for (var i=0,ic=dailies.length; i<ic; i++) {
            var obj = dailies[i];
            if (obj.completed) {
                continue;
            }
            if (obj.dueToday) { // Daily is due today
                dailiesIncomplete.push(obj);
            }
            else {
                dailiesIncompleteGrey.push(obj.text);
            }
        }

        if ((dailiesIncomplete.length + dailiesIncompleteGrey.length) == 0) {
            DASHBOARD[orderId] = {'label': title,
                'hoverText': 'you have completed all Dailies and Grey Dailies',
                'value': '0', 'status': 'safe'};
            return;
        }
        var html = '';
        // html += '<p style="font-size:18px; color:orange" font-weight:bold">IMPORTANT: If you use the new Dailies "Start Date" or "Every X Days" option, the damage estimates and list of incomplete Dailies might be <strong>wrong</strong>. If you absolutely rely on the information here to manage your Dailies, it is recommended that you don\'t use the new options until this message disappears (in a day or two).</p>';
        if (dailiesIncomplete.length > 0) {
            html += '<p>The table below shows the Dailies that are due ' +
                    'today and have not yet been completed. ';
            var damageToYouText;
            if (quest.content && quest.content.boss) {
                damageToYouText = 'damage to you alone';
                html += 'For each Daily, it tells you how much damage the' +
                        ' Daily will let the ' +
                        wiki('Quests', 'quest') + ' ' +
                        wiki('Boss', 'boss') +
                        ' do to all quest participants including you ("<strong>damage to party</strong>"); how much damage you alone will take from the Daily - this is the damage you would take if you were not on a boss quest ("<strong>damage to you alone</strong>"), and the sum of the previous two values ("<strong>total damage to you</strong>").';
            }
            else {
                damageToYouText = 'damage to you';
                html += 'It tells you the estimated damage you will take ' +
                        'from each Daily.';
            }
            html += ' Click on any column header to sort by that column; ' +
                    'for example; sort by "' + damageToYouText + '" ' +
                    'to find the most ' +
                    'damaging Dailies to action first if you won\'t have ' +
                    'time to do them all. The damage estimates take into ' +
                    'account damage reduction from partially-completed ' +
                    wiki('Checklist#Dailies', 'checklists') +
                    ', so you might find it is better to do ' +
                    'a blue Daily instead of a mostly-completed red Daily.' +
                    '</p><table></table>';
        }
        else {
            html += '<p>You have completed all of the Dailies due today.</p>';
        }
        if (everyXDaysInUse) {
            html += '<h3>Warning: "Every X Days" Dailies</h3>' +
                    '<p>You have one or more Dailies that use the "Every X Days" repeat setting. If you live in a timezone where daylight savings is used for part of the year, then it is possible that these Dailies are being incorrectly reported here as due or not due. If Habitica is telling you that an "Every X Days" Daily is due, but the Data Display Tool is saying it isn\'t, then Habitica is likely to be correct. You can get around this problem by editing each of the affected Dailies to set the Start Date to a date that is more recent than the last daylight savings change in your region. A proper fix for this will be done soon.</p>';
        }
        if (dailiesIncompleteGrey.length > 0) {
            html += '<h3>Grey Dailies</h3><p>' +
                    pluralise('This', dailiesIncompleteGrey.length) + ' ' +
                    wiki('Dailies#Grey_Dailies', 'Grey ' +
                        pluralise('Daily', dailiesIncompleteGrey.length)) +
                    ' ' +
                    pluralise('is', dailiesIncompleteGrey.length) +
                    ' <span class="highlight">not</span> due today but' +
                    ' you can still complete ' +
                    pluralise('it', dailiesIncompleteGrey.length) +
                    ' for extra rewards:</p><ul class="padded"><li>' +
                    dailiesIncompleteGrey.join('</li><li>') +
                    '</li></ul>';
        }
        DASHBOARD[orderId] = {'label': title,
            'hoverText': 'number of Dailies you have not yet completed ' +
                         '(click for more information)',
            'target': id,
            'value': dailiesIncomplete.length,
            'status': ((dailiesIncomplete.length > 0) ? 'danger' : 'safe')
            };
        TOC[orderId]  = {'target': id, 'title':  title};
        MAIN[orderId] = {'id': id, 'title': title, 'longContent': true,
                   'function': ((dailiesIncomplete.length > 0) ?
                                createDailiesIncompleteTable : false),
                   'html': html};

        function createDailiesIncompleteTable() {
            // Use DataTables to build the table (the table tag must be
            // visible first for layout to be correct):
            $('#dailiesIncompleteSection').show();
            $('#dailiesIncompleteSection table').dataTable({
                'aaData': dailiesIncomplete,
                'aoColumns': [
            { 'mData' : 'orderDailies',   'sClass': 'center',
              'sTitle': 'order in Habitica',
            },
            { 'mData' : 'streak',         'sClass': 'center',
              'sTitle': 'current streak',
            },
            { 'sTitle': 'value', 'sClass': 'center', 'asSorting':['desc','asc'],
              'mData': function ( source, type, val ) {
                if (type === 'set') {
                  return; // http://datatables.net/ref#mData
                }
                else if (type === 'display') {
                  return source.valueColourHtml;
                }
                else if (type === 'filter') {
                  return source.colour.name;
                }
                // 'sort', 'type' and undefined all just use the integer
                return source.value;
              }
            },
            { 'mData' : 'damageToParty',   'sClass': 'center',
              'sTitle': 'damage to party', 'asSorting': ['desc','asc'],
              'bVisible': ((quest.content && quest.content.boss) ? true:false),
            },
            { 'mData' : 'damageToUser',    'sClass': 'center',
              'sTitle': damageToYouText,   'asSorting': ['desc','asc'],
            },
            {                              'sClass': 'center',
              'sTitle': 'total damage to you',   'asSorting': ['desc','asc'],
              'bVisible': ((quest.content && quest.content.boss) ? true:false),
              'mData': function ( source, type, val ) {
                  return Math.round((source.damageToParty +
                                     source.damageToUser)*10)/10;
              },
            },
            { 'sTitle': 'stealthed',       'sClass': 'center',
              'mData': function ( source, type, val ) {
                  return (source.stealthed) ? 'yes' : 'no';
              },
              'bVisible': user.stats.buffs.stealth,
            },
            { 'mData' : 'text',
              'sTitle': 'task',
            },
                ],
                'sDom': '<"clear"><"top"if>rt<"bottom"><"clear">',
                'bAutoWidth': false,
                'bPaginate': false,
                'bDeferRender': true,
                "sScrollX": "100%",
                "bDestroy": true,
            });
            $('#dailiesIncompleteSection').hide();
            return;
        }
    }


    function dailiesHistory() {
        var id      = 'dailiesHistorySection';
        var title   = 'Dailies History';
        var orderId = 'dailiesHistory';

        // preprocess the Dailies to find all the dates on which data
        // exists, and to work out if each day was a success or fail
        // or neither (e.g., Grey Daily) based on whether the day's value
        // is higher or lower than the previous day's:
        var allDates = {};
        for (var i=0,ic=dailies.length; i<ic; i++) {
            var obj = dailies[i];
            obj['historyItems'] = {};
            var previousValue = null;
            if (obj.history) {
                for (var j=0,jc=obj.history.length; j<jc; j++) {
                    // Get the date that is recorded in this history entry
                    // for this Daily:
                    var historyDate = new Date(obj.history[j].date);
                    // Subtract one day from that date because the value assigned
                    // to this history entry comes from the action that was
                    // done to the Daily on the PREVIOUS day -- i.e., if you
                    // tick off a Daily, then after the cron time (i.e., on the
                    // NEXT day), the Daily's value will be increased and that
                    // new value will be recorded with the new day's date:
                    historyDate.setHours(historyDate.getHours() - 24);
                    var formattedDate = myDateConverter(historyDate);
                    var value = obj.history[j].value;
                    var success = '-'; // default (Grey Daily or no data)
                    var status = 'neutral'; // default (Grey Daily or no data)
                    if ( (previousValue === null && value > 0) ||
                         (previousValue !== null && value > previousValue) ) {
                        success = '✓'; // user did the Daily
                        status = 'safe';
                    }
                    else if ((previousValue === null && value < 0) ||
                             (previousValue !== null && value < previousValue)) {
                        success = 'x'; // user did not do the Daily
                        status = 'danger';
                    }
                    obj['historyItems'][formattedDate] = [];
                    obj['historyItems'][formattedDate]['value'] = success;
                            // + '<br />' + (Math.round(value * 10) / 10); // TST
                    obj['historyItems'][formattedDate]['status'] = status;
                    allDates[formattedDate] = true;
                    previousValue = value;
                }
            }
        }
        var allDatesInOrder = Object.keys(allDates).sort().reverse();
        var datesWithGaps = {};
        var previousDate = null;
        var headerRow = '<thead><tr><th>task</th>';
        for (var i=0,ic=allDatesInOrder.length; i<ic; i++) {
            var date = new Date(allDatesInOrder[i]);
            var missingDate = '';
            if (previousDate !== null) {
                if ((previousDate - date) > 24*60*60*1000) {
                    // there's a gap between the dates of more than one day
                    datesWithGaps[allDatesInOrder[i]] = true;
                    missingDate = 'missingDate';
                }
            }
            headerRow += '<th class="' + missingDate + '">' +
                         allDatesInOrder[i] + '&nbsp;</th>';
            previousDate = date;
        }
        headerRow += '</tr></thead>';
        headerRow = headerRow.replace(/>20/g, ">'"); // remove century
        headerRow = headerRow.replace(/-/g, "-<br />"); // line break after -
        var tableBody = '';
        for (var i=0,ic=dailies.length; i<ic; i++) {
            var obj = dailies[i];
            tableBody += '<tr><td>' + obj.text + '</td>';
            for (var j=0,jc=allDatesInOrder.length; j<jc; j++) {
                var missingDate = (datesWithGaps[allDatesInOrder[j]]) ?
                                  'missingDate' : '';
                var status = 'neutral';
                var value  = '-';
                if (obj['historyItems'][allDatesInOrder[j]]) {
                    status = obj['historyItems'][allDatesInOrder[j]]['status'];
                    value  = obj['historyItems'][allDatesInOrder[j]]['value'];
                }
                tableBody += '<td class="' +
                             status + ' ' + missingDate + '">' +
                             value + '</td>';
            }
            tableBody += '</tr>' ;
        }

        var html =
'<div id="dailiesHistoryExplanationToggle" class="showHideToggle" data-target="dailiesHistoryExplanation" data-linktext="explanation">show explanation</div>' +
'<div id="dailiesHistoryExplanation" class="hide">' +
'    <p>The table below shows historical data for your Dailies. If you are a subscriber, you will see data for every day going back to the date on which you subscribed. If you are not a subscriber, you will see data for every day for the past week, but before that your data points start to be merged together (this is to save on expensive database storage space). In the table are symbols indicating your actions on each day:</p><ul class="padded"><li><span class="safe">V</span> You ticked off the Daily, even if it was a ' +
wiki('Dailies#Grey_Dailies', 'Grey Daily') +
', or you left the Daily incomplete but cast ' +
wiki('Healer#Skills', 'Searing Brightness') +
' or ' +
wiki('Warrior#Skills', 'Brutal Smash') +
' on it.</li><li><span class="danger">x</span> You did not tick off the Daily but you should have (it was due that day), or you used the ' + wiki('Orb_of_Rebirth', 'Orb of Rebirth') + ' or ' + wiki('Settings#Reset_Account', 'Reset') + ' to set all your tasks back to yellow.</li><li><span class="neutral">-</span> You did not tick off the Daily but you took no damage from it for several possible reasons (the Daily was not due that day; you ticked off all of the ' +
wiki('Checklist#Dailies', 'checklist') +
' items under that Daily, although not the Daily itself; you evaded the Daily with ' +
wiki('Rogue#Skills', 'Stealth') + '; you were ' +
wiki('Tavern', 'resting in the inn') +
'; you had not logged in to Habitica that day; the Daily did not yet exist on that day). This symbol will also appear frequently for old data for non-subscribers because it is not possible to correctly determine the actions you took after your data has been merged.</li></ul><p>Vertical grey bars in the table indicate gaps in the historical record (e.g., periods of a day or more in which you were resting in the inn).</p>' +
'   <div class="showHideToggle closer" data-target="dailiesHistoryExplanation" data-resettoggletext="dailiesHistoryExplanationToggle">hide explanation</div>' +
'</div>' +
                   '<table>' +
                   headerRow + '<tbody>' +
                   tableBody + '</tbody></table>';
        TOC[orderId]  = {'target': id, 'title':  title};
        MAIN[orderId] = {'id': id, 'title': title, 'longContent': true,
                         'html': html};

// LIST FORMAT FOR REASONS (INCOMPLETE): <li><span class="neutral">-</span> you did not tick off the Daily but you took no damage from it for a reason such as:<ul><li>the Daily was not due that day</li><li>you evaded the Daily with <a href="http://habitica.wikia.com/wiki/Rogue#Skills">Stealth</a></li><li>you were <a href="http://habitica.wikia.com/wiki/Tavern">resting in the inn</a></li><li>you had not logged in to Habitica that day</li><li>the Daily did not yet exist on that day</li></ul></li>      #dailiesHistorySection > ul ul { margin-left: 2em; }
    }


    function todosDated() {
        var id      = 'todosDatedSection';
        var title   = 'To-Dos with Dates';
        var orderId = 'todosDated';

        var today = myDateConverter(new Date(), 'medium');
        var lastWeek = new Date();
        lastWeek.setDate(lastWeek.getDate() - 7);
        lastWeek = myDateConverter(lastWeek, 'medium');

        var itemsDated = [], itemsNotDated = [];
        var countDue = 0;
        var dangerTodoFound = false;
        for (var i=0,ic=todos.length; i<ic; i++) {
            var obj = todos[i];
            var challenge = (obj.challenge && obj.challenge.id)
                          ? ' <span class="challenge">(challenge To-Do)</span>'
                          : '';
            var dateClass = 'notDue';
            var dateString = '';
            if (obj.date) {
                var date = myDateConverter(obj.date, 'medium');
                if (date <= today) {
                    dateClass = 'due';
                    countDue++;
                    if (! challenge || date > lastWeek) {
                        // An overdue To-Do is not dangerous if it is from a
                        // challenge and is more than a week old (because the
                        // user probably doesn't care about it).
                        dangerTodoFound = true;
                    }
                }
                dateString = '<span class="date">' + date + '</span> ';
            }
            var todoString = '<li class="' + dateClass + '">' + dateString +
                             obj.text + challenge + '</li>';
            if (obj.date) {
                itemsDated.push(todoString);
            }
            else {
                itemsNotDated.push(todoString);
            }
        }
        if (itemsDated.length === 0) {
      return;
        }
        var html = '<ul class="padded">' +
                   itemsDated.sort().join('') +
                   '</ul>' +
                   '<hr /><h2>To-Dos without Dates</h2>' +
                   '<ul class="padded">' +
                   itemsNotDated.join('') +
                   '</ul>';
        if (countDue) {
            DASHBOARD[orderId] = {'label': 'To-Dos Due Today',
                'hoverText': 'number of To-Dos due today or overdue ' +
                             '(click for more information)',
                'target': id,
                'value': countDue,
                'status': ((dangerTodoFound) ? 'danger' : 'neutral')};
        }
        TOC[orderId]  = {'target': id, 'title':  title};
        MAIN[orderId] = {'id': id, 'title': title, 'html': html};
    }


    function todosCompletedTable() {
        var id      = 'todosCompletedSection';
        var title   = 'To-Dos Completed';
        var orderId = 'todosCompleted';
        var html = '<p>This shows all of your completed To-Dos that Habitica has in its archive (not necessarily all the To-Dos that you have ever completed because Habitica keeps only recent ones). This is the same information that can be obtained by using the <a href = "https://habitica.com/#/options/settings/export">Export User Data</a> feature.</a><br /><span class="lowlight">For information about this table\'s advanced features, read the explanation for the "Task Overview" section, which has a similar table.</span></p>' +
        '<table></table>';
        TOC[orderId]  = {'target': id, 'title':  title};
        MAIN[orderId] = {'id': id, 'title': title, 'longContent': true,
                         'function': createTodosCompletedTable,
                         'html': html};

        function createTodosCompletedTable() {
            // Use DataTables to build the table (the table tag must be
            // visible first for layout to be correct):
            $('#todosCompletedSection').show();
            $('#todosCompletedSection table').dataTable({
                'aaData': todosCompleted,
                'aoColumns': [
            { 'mData' : 'order', // needed to ensure correct starting sort
              'sTitle': '#',    'bVisible': false,
            },
            { 'mData' : 'attributePretty',  'sClass': 'center',
              'sTitle': 'attr.',            'sWidth': '10%',
            },
            { 'mData' : 'colour.label',
              'sTitle': 'colour',     'sClass': 'center', 'bVisible': false,
            },
            { 'sTitle': 'value',      'sClass': 'center', 'sWidth': '10%',
              'mData': function ( source, type, val ) {
                if (type === 'set') {
                  return; // http://datatables.net/ref#mData
                }
                else if (type === 'display') {
                  return source.valueColourHtml;
                }
                else if (type === 'filter') {
                  return source.colour.name;
                }
                // 'sort', 'type' and undefined all just use the integer
                return source.value;
              }
            },
            { 'sTitle': '<abbr title="creation date">added</abbr>',
              'sClass': 'center',       'sWidth': '10%',
              'asSorting': ['desc','asc'],
              'mData': function ( source, type, val ) {
                if (type === 'set') {
                  return;
                }
                else if (type === 'display') {
                  return '<abbr title="' +
                         source.creation.dateAndTime + '">' +
                         source.creation.shortDate +
                         '</abbr>';
                }
                else {
                  return source.creation.dateAndTime;
                }
              }
            },
            { 'sTitle': '<abbr title="completion date">completed</abbr>',
              'sClass': 'center',       'sWidth': '10%',
              'asSorting': ['desc','asc'],
              'mData': function ( source, type, val ) {
                if (type === 'set') {
                  return;
                }
                else if (type === 'display') {
                  return '<abbr title="' +
                         source.completion.dateAndTime + '">' +
                         source.completion.shortDate +
                         '</abbr>';
                }
                else {
                  return source.completion.dateAndTime || null;
                }
              }
            },
            { 'sTitle': 'text and notes ', 'sWidth': '*',
              'mData': function ( source, type, val ) {
                if (type === 'set') {
                  return;
                }
                else {
                  return source.text + '<br />' +
                         source.notes;
                }
              }
            },
                ],
                // 'scrollY': 300,
                // 'bInfo': false,
                // 'sDom': 'W<"clear"><"top"if>rt<"bottom"iflp><"clear">',
                'sDom': 'W<"clear"><"top"if>rt<"bottom"><"clear">',
                'bAutoWidth': false,
                'bPaginate': false,
                'bDeferRender': true,
                // 'bSortClasses': false,
                "sScrollX": "100%",
                // "sScrollXInner": "200%",
                "bDestroy": true, // allows table to recreate on refetch
                'oColumnFilterWidgets': {
                    'aiExclude': [ 0, 3, 4, 5, 6 ],
                }
            });
            $('#todosCompletedSection').hide();
            return;
        }
    }


    function statsAndStreaks() {
        var id      = 'statsAndStreaksSection';
        var title   = 'Stats and Streaks Backup';
        var orderId = 'statsAndStreaks';
        var html = '<p>This section lists information you might need if you ' +
            wiki('Death_Mechanics', 'die') +
            ' due to circumstances out of your' +
            ' control (e.g., if you lose internet access and can\'t tick' +
            ' off your Dailies). Your stats (Health, etc) can be restored' +
            ' using "Fix Character Values" in the ' +
            wiki('Settings') +
            ' page. Your Dailies\' streaks can be reset using ' +
            wiki('Streaks', 'Restore Streak') +
            ' in the Avanced Options for each Daily.</p>' +
            '<p><span class="highlight">IMPORTANT!</span> If you have ' +
            'already died, this page <span class="highlight">cannot</span> ' +
            'tell you what your stats and streaks were before death; it\'s ' +
            'impossible to get that information. If you\'d like to protect ' +
            'yourself against the effects of a death that isn\'t your ' +
            'fault, visit this page every day or every few days, and take a ' +
            'screenshot of this information or copy it to a text file.</p>' +
            '<div class="subsection"><p class="forCopyPaste">&nbsp;</p>' +
            '<h3>Your Stats</h3><ul>' +
            '<li><span>' + (Math.round(user.stats.hp  * 100) / 100) +
               '</span> Health' +
            '<li><span>' + (Math.round(user.stats.exp * 100) / 100) +
               '</span> Experience' +
            '<li><span>' + (Math.round(user.stats.gp  * 100) / 100) +
               '</span> Gold' +
            '<li><span>' + (Math.round(user.stats.mp  * 100) / 100) +
               '</span> Mana' +
            '<li><span>' + user.stats.lvl +
               '</span> Level' +
            '<li><span>' + (user.achievements.streak || 0) +
               '</span> 21-Day Streaks' +
            '</ul></div>' +
            '<div class="subsection"><p class="forCopyPaste">&nbsp;</p>' +
            '<h3>Your Dailies\' Streaks</h3><ul class="padded">';
        for (var i=0,ic=dailies.length; i<ic; i++) {
            var obj = dailies[i];
            html += '<li><span>'
                  + obj.streak + '</span> '
                  + obj.text + '</li>';
        }
        html += '</ul></div><div class="clear"></div>';
        TOC[orderId]  = {'target': id, 'title':  title};
        MAIN[orderId] = {'id': id, 'title': title, 'html': html};
    }


    function skillsAndBuffs() {
        var conLink       = wiki('Constitution', 'CON');
        var intLink       = wiki('Intelligence', 'INT');
        var perLink       = wiki('Perception',   'PER');
        var strLink       = wiki('Strength',     'STR');
        var taskValueLink = wiki('Task_Value',   'value');
        var classLink     = wiki('Class_System', 'class');
        var id      = 'skillsAndBuffsSection';
        var title   = 'Skills and Buffs';
        var orderId = 'skillsAndBuffs';

        var html = '<p>This section describes the skills you ';
        var more = false;
        if (user.preferences.disableClasses) {
            html += 'would be able to use if you chose a ' + classLink + '.';
        }
        else if (user.stats.lvl < 11) {
            html += 'will be able to use when you reach levels 11 to 14, ' +
                    'if you choose a ' + classLink + '.';
        }
        else if (user.stats.lvl < 14) {
            html += 'have now or will have when you reach level 14,';
            more = true;
        }
        else {
            html += 'have available to you';
            more = true;
        }
        if (more) {
            html += ' and the effect they will have if you cast them '+
                   'now. It also describes the skills belonging to other ' +
                   'classes and the effect they would have if you changed ' +
                   'class but kept your current ' +
                   wiki('Character_Attributes', 'attributes') +
                   ' (although in reality, your attributes will usually' +
                   ' change at least a little when you change class).';
        }
        html += ' The wiki has more information about ' +
                wiki('Skills', 'skills') + ' and ' +
                wiki('Buff', 'buffs') + '.</p>';
        html += '<p>Most of the skills can be made stronger by' +
                ' increasing your attributes. Some skills are made stronger' +
                ' by increasing only your <strong>unbuffed</strong>' +
                ' attributes - i.e., your attributes gained from equipment' +
                ' or attribute points. Buffs that you have already gained' +
                ' will not make those skills stronger.</p>';

        var nowMP        = Math.round(user.stats.mp  * 10) / 10;
        var maxMP        = 2 * computedStats['int'] + 30;
        var maxMPNoBuffs = 2 * computedStatsNoBuffs['int'] + 30; // XXX add perfect day buff
        var cronMP = (maxMP > 100) ? maxMP/10 : 10;
        // XXX add unbuffed stats, put into table, add attribute links
        html += '<p>Your current ' +
                wiki('Character_Attributes', 'attributes') + ' and ' +
                wiki('Mana Points', 'mana') + ' values are:</p>' +
                '<ul class="attributes">' +
                '<li><label>Strength (STR):</label> '     +
                     ((computedStats['str'] < 100) ? '&nbsp;&nbsp;' : '') +
                       computedStats['str'] + ' ' + '<span class="details">' +
                       computedStats.detailsPretty['str'] + '</span></li>' +
                '<li><label>Intelligence (INT):</label> ' +
                     ((computedStats['int'] < 100) ? '&nbsp;&nbsp;' : '') +
                       computedStats['int'] + ' ' + '<span class="details">' +
                       computedStats.detailsPretty['int'] + '</span></li>' +
                '<li><label>Constitution (CON):</label> ' +
                     ((computedStats['con'] < 100) ? '&nbsp;&nbsp;' : '') +
                       computedStats['con'] + ' ' + '<span class="details">' +
                       computedStats.detailsPretty['con'] + '</span></li>' +
                '<li><label>Perception (PER):</label> '   +
                     ((computedStats['per'] < 100) ? '&nbsp;&nbsp;' : '') +
                       computedStats['per'] + ' ' + '<span class="details">' +
                       computedStats.detailsPretty['per'] + '</span></li>' +
                '<li><label>maximum MP:</label> ' +
                     ((maxMP < 100) ? '&nbsp;&nbsp;' : '') +
                       maxMP + '</li>' +
                // '<li><label>MP gained at cron:</label> ' + // XXX uncomment when maxMPNoBuffs is fixed
                     // ((cronMP < 100) ? '&nbsp;&nbsp;' : '') +
                       // cronMP +
                       // ' <span class="details">' +
                       // '(if all your due Dailies are completed!)' +
                       // '</span></li>' +
                '<li><label>current MP:</label> ' +
                     ((nowMP < 100) ? '&nbsp;&nbsp;' : '') +
                       nowMP + '</li>' +
                '</ul>';

        html += '<p style="font-size:18px; color:orange; font-weight:bold">' +
                'The information below is only an approximation.' +
                // 'The information below is highly experimental and is' +
                // ' still undergoing testing. Do not rely upon it until this' +
                // ' message has been removed!' +
                // ' If you notice the skills behaving differently than' +
                // ' described here, please ' + tellMe
                '.</p>';

        var conIncreaseDamageExplanation      = '';
        var conIncreaseDamageExplanationParty = '';
        if (quest.content && quest.content.boss) {
            conIncreaseDamageExplanation = 'This will reduce the damage ' +
                    'that you take from your negative Habits and from ' +
                    'your Dailies directly. It will not reduce the damage ' +
                    'that your quest boss does to you.';
            conIncreaseDamageExplanationParty = 'This will reduce the damage ' +
                    'that you and your party members will each take from ' +
                    'your own negative Habits and your own Dailies directly. ' +
                    'It will not reduce the damage that your quest boss ' +
                    'does to each of you.';
        }

        var before = ' before casting it.';
        var skills = { // each function returns:
                       // The target of the skill (blank if the default
                       // target doesn't need to be explained);
                       // The effect of the skill;
                       // Additional explanatory text (can be blank);
                       // How to increase effect of the skill (can be blank).

            'fireball': function() { // Mage - Burst of Flames
                // XXX_SOON add effects of crit
                var bluestTaskName = bluestTask.text;
                var bluestTaskType = bluestTask.typePretty;
                var currentValue   = bluestTask.value;
                var tempValue = Math.ceil(
                        ((currentValue < 0) ? 1 : currentValue + 1) * 0.075);
                var bonus = computedStats.int * tempValue;
                var xpIncrease = diminishingReturns(bonus, 75);
                var questIncrease = Math.ceil(computedStats.int * .1);
                currentValue  = Math.round(currentValue  * 10) / 10;
                xpIncrease    = Math.round(xpIncrease * 10) / 10;
                questIncrease = Math.round(questIncrease * 10) / 10;
                var effects = 'This skill is best cast on your ' +
                              '<span class="taskName">' +
                              bluestTaskName + '</span> ' +
                              bluestTaskType + '. You will gain ' +
                              xpIncrease + ' XP.';
                var additional = 'There is a 3% or greater chance of a ' +
                                 'critical hit which will increase your ' +
                                 'XP gained';
                if ((quest.content && quest.content.boss) || tavernBoss) {
                    var more = '';
                    effects += ' You will do ' +
                               questIncrease + ' damage to ' +
                               bossesLabel + '.';
                    additional += ' and the damage done to the ' +
                                  bossesWord;
                } // XXX_LATER if no quest: say that it WOULD affect bosses
                        // more = ' If you were on a quest, you would do ' +
                               // questIncrease + ' damage to the quest boss.';
                additional += ' by an amount based on your ' +
                    perLink + '.';
                var increase = 'To increase all effects of the skill, ' +
                               'increase your ' + intLink + before;
                return ['your bluest task',
                        effects,
                        additional,
                        increase]; },

            'mpheal': function() { // Mage - Ethereal Surge
                var bonus = Math.ceil(
                        diminishingReturns(computedStats['int'], 25, 125));
                var increase = 'To increase the effect of the skill, ' +
                               'increase your ' + intLink + before;
                return ['',
                        'Each of your party members will receive ' +
                        bonus + ' MP, except for yourself.',
                        'When you cast this skill, it will initially seem ' +
                        'as if you do receive ' +
                        bonus + ' MP (i.e., the skill will seem to cost only ' +
                        (30-bonus) + ' MP), but the ' +
                        bonus + ' MP will later be removed from your account.' +
                        ' The true cost of this skill to you is 30 MP and ' +
                        'it benefits only your party members, not you.',
                        increase]; },

            'earth': function() { // Mage - Earthquake
                var buff = Math.ceil(
                    diminishingReturns(computedStatsNoBuffs['int'], 30, 200));
                var increase = 'To increase the effect of the skill, ' +
                               'increase your unbuffed ' + intLink + before;
                return ['',
                        'Each of your party members will have their ' +
                        intLink + ' increased by ' +
                        buff + '.',
                        '',
                        increase]; },

            'frost': function() { // Mage - Chilling Frost
                var msg = 'all your uncompleted Dailies will not have ' +
                          'their streaks reset to zero overnight.';
                var effects = (user.stats.buffs.streaks) ?
                              'You have already cast this today, so ' +
                              msg + ' Casting it again will have no effect.' :
                              'If you cast this, ' +
                              msg;
                return ['',
                    effects,
                    'After you have cast this, your <a href="' +
                    'https://habitica.com/#/options/profile/stats">' +
                    'User --> Stats page</a> will state "Streaks Frozen".']; },

            'heal': function() { // Healer - Healing Light
                var inc = (computedStats.con + computedStats.int + 5) * 0.075;
                var health = Math.round((user.stats.hp + inc) * 10) / 10;
                if (health > 50) { health = 50; }
                var increase = 'To increase the effect of the skill, ' +
                               'increase your ' + conLink + ' or ' +
                               intLink + ' or both' + before;
                return ['',
                        'Your health will be increased by ' +
                        inc + ' to a total of ' + health + ' HP.',
                        '',
                        increase]; },

            'brightness': function() { // Healer - Searing Brightness
                var inc = 4 * computedStats.int / (computedStats.int + 40);
                var increase = 'To increase the effect of the skill, ' +
                               'increase your ' + intLink + before;
                return ['',
                        'The ' + taskValueLink + ' of each of your tasks ' +
                        'will be increased (made more blue) by ' +
                        (Math.round(inc * 100) / 100) + '.',
                        'For example, your bluest non-challenge task (the ' +
                        '<span class="taskName">' +
                        bluestTask.text + '</span> ' +
                        bluestTask.typePretty +
                        ') will have its value changed from ' +
                        (Math.round(bluestTask.value * 100) / 100) + ' to ' +
                        (Math.round((bluestTask.value + inc) * 100) / 100) +
                        '. Your reddest non-challenge task (the '+
                        '<span class="taskName">' +
                        reddestTask.text + '</span> ' +
                        reddestTask.typePretty +
                        ') will have its value changed from ' +
                        (Math.round(reddestTask.value * 100) / 100) + ' to ' +
                        (Math.round((reddestTask.value + inc) * 100) / 100) +
                        '.',
                        increase]; },

            'protectAura': function() { // Healer - Protective Aura
                var conInc = Math.ceil(
                    diminishingReturns(computedStatsNoBuffs['con'], 200, 200));
                var con = computedStats.con + conInc;
                var increase = 'To increase the effect of the skill, ' +
                               'increase your unbuffed ' + conLink + before;
                return ['',
                        'The ' + conLink + ' of each party member, ' +
                        'including you, will be increased by ' +
                        conInc + '. Your own CON will then be ' +
                        con + '.',
                        conIncreaseDamageExplanationParty,
                        increase]; },

            'healAll': function() { // Healer - Blessing
                var inc = (computedStats.con + computedStats.int + 5) * 0.04;
                var health = Math.round((user.stats.hp + inc) * 10) / 10;
                if (health > 50) { health = 50; }
                inc = Math.round(inc * 10) / 10;
                var increase = 'To increase the effect of the skill, ' +
                               'increase your ' + conLink + ' or ' +
                               intLink + ' or both' + before;
                return ['',
                        'The health of each party member, including you, ' +
                        'will be increased by ' +
                        inc + ' (to a maximum of 50 HP). Your own health ' +
                        'will then be ' + health + '.',
                        '',
                        increase]; },

            'smash': function() { // Warrior - Brutal Smash
                // XXX_SOON add effects of crit
                var bonus = computedStats.str;
                var inc = Math.round(
                        diminishingReturns(bonus, 2.5, 35) * 100) / 100;
                var effects = 'Your task\'s ' + taskValueLink +
                              ' will be increased (made less red) by ' +
                              inc + ' points.';
                var additional = 'There is a 3% or greater chance of a ' +
                        'critical hit which will further increase your ' +
                        'task\'s value by an amount based on your ' +
                        conLink + '.' +
                        '<br />This skill is best cast on ' +
                        'a red Daily or Habit that is hurting you ' +
                        'often (e.g., your ' +
                        '<span class="taskName">' +
                        reddestHabit.text + '</span> Habit or your ' +
                        '<span class="taskName">' +
                        reddestDaily.text + '</span> Daily). <br />' +
                        'You can also cast it on a red To-Do if you want ' +
                        'to receive smaller rewards when you complete that ' +
                        'To-Do.<br />The "Task Overview" section will show ' +
                        'you your reddest tasks (sort the table by value).';
                if ((quest.content && quest.content.boss) || tavernBoss) {
                    var questIncrease = Math.round(
                            diminishingReturns(bonus, 55, 70) * 10) / 10;
                    var more = '';
                    effects += ' You will do ' +
                               questIncrease + ' damage to ' +
                               bossesLabel + '.';
                    additional += '<br /> If you want to use the skill to ' +
                            'damage the ' +
                            bossesWord + ' but don\'t want to adjust the ' +
                            'rewards you would receive for a task, then ' +
                            'cast the skill on any completed To-Do or on ' +
                            'your bluest task (your ' +
                            '<span class="taskName">' +
                            bluestTask.text + '</span> ' +
                            bluestTask.typePretty + ').';
                } // XXX_LATER if no quest: say that it WOULD affect bosses
                        // more = ' If you were on a quest, you would do ' +
                               // questIncrease + ' damage to the quest boss.';
                var increase = 'To increase all effects of the skill, ' +
                               'increase your ' + strLink + before;
                return ['a red Habit or Daily',
                        effects,
                        additional,
                        increase]; },

            'defensiveStance': function() { // Warrior - Defensive Stance
                var increase = 'To increase the effect of the skill, ' +
                               'increase your unbuffed ' + conLink + before;
                var inc = Math.ceil(
                        diminishingReturns(computedStatsNoBuffs.con, 40, 200));
                return ['',
                        'Your ' + conLink + ' will increase from ' +
                        computedStats.con + ' to ' +
                        (computedStats.con + inc) + '.',
                        conIncreaseDamageExplanation,
                        increase]; },

            'valorousPresence': function() { // Warrior - Valorous Presence
                var inc = Math.ceil(
                        diminishingReturns(computedStatsNoBuffs.str, 20, 200));
                var increase = 'To increase the effect of the skill, ' +
                               'increase your unbuffed ' + strLink + before;
                return ['',
                        'Each of your party members will have their ' +
                        strLink + ' increased by ' +
                        inc + '. Your own STR will increase from ' +
                        computedStats.str + ' to ' +
                        (computedStats.str + inc) + '.',
                        '',
                        increase]; },

            'intimidate': function() { // Warrior - Intimidating Gaze
                var inc = Math.ceil(
                        diminishingReturns(computedStatsNoBuffs.con, 24, 200));
                var increase = 'To increase the effect of the skill, ' +
                               'increase your unbuffed ' + conLink + before;
                return ['',
                        'Each of your party members will have their ' +
                        conLink + ' increased by ' +
                        inc + '. Your own CON will increase from ' +
                        computedStats.con + ' to ' +
                        (computedStats.con + inc) + '.',
                        conIncreaseDamageExplanation,
                        increase]; },

            'pickPocket': function() { // Rogue
                var bluestTaskName = bluestTask.text;
                var bluestTaskType = bluestTask.typePretty;
                var currentValue   = bluestTask.value;
                var bonus = calculateBonus(currentValue, computedStats.per);
                var inc = Math.round(
                        diminishingReturns(bonus, 25, 75) * 100) / 100;
                var increase = 'To increase the effect of the skill, ' +
                               'increase your ' + perLink + before;
                return ['your bluest task',
                        'This skill is best cast on your ' +
                        '<span class="taskName">' +
                        bluestTaskName + '</span> ' +
                        bluestTaskType + '. You will gain ' +
                        inc + ' GP.',
                        '',
                        increase]; },

            'backStab': function() { // Rogue - Backstab
                // XXX_SOON add effects of crit
                var bluestTaskName = bluestTask.text;
                var bluestTaskType = bluestTask.typePretty;
                var currentValue   = bluestTask.value;
                var bonus = calculateBonus(currentValue, computedStats.str);
                var xpBonus = Math.round(
                        diminishingReturns(bonus, 75, 50) * 10) / 10;
                var gpBonus = Math.round(
                        diminishingReturns(bonus, 18, 75) * 100) / 100;
                var increase = 'To increase the effect of the skill, ' +
                               'increase your ' + strLink + before;
                return ['your bluest task',
                        'This skill is best cast on your ' +
                        '<span class="taskName">' +
                        bluestTaskName + '</span> ' +
                        bluestTaskType + '. You will gain ' +
                        gpBonus + ' GP and ' +
                        xpBonus + ' XP.',
                        'There is a 30% or greater chance of a critical hit ' +
                        'which will increase your XP and GP ' +
                        'gained by an amount based on your ' +
                        strLink,
                        increase]; },

            'toolsOfTrade': function() { // Rogue
                var inc = Math.ceil(
                        diminishingReturns(computedStatsNoBuffs.per, 100, 50));
                var per = computedStats.per + inc;
                var increase = 'To increase the effect of the skill, ' +
                               'increase your unbuffed ' + perLink + before;
                return ['',
                        'The ' + perLink + ' of each party member, ' +
                        'including you, will be increased by ' +
                        inc + '. Your own PER will then be ' +
                        per + '.',
                        '',
                        increase]; },

            'stealth': function() { // Rogue - Stealth
                var stealth = user.stats.buffs.stealth;
                var avoid = Math.ceil(diminishingReturns(
                        computedStats.per, dailies.length * 0.64, 55));
                var effects;
                if (stealth) {
                    effects = 'You have already cast stealth today, ' +
                              'and so you will already avoid ' +
                              stealth + ' Dailies tonight. If you cast ' +
                              'it again now, you will avoid an additional ' +
                              avoid + ' Dailies (' +
                              (stealth + avoid) + ' in total).';
                }
                else {
                    effects = 'You will avoid ' +
                              avoid + ' Dailies tonight.';
                }
                var additional = 'Those Dailies will not cause damage and' +
                    ' their streaks will not reset. If you are on a ' +
                    wiki('Boss', 'boss') + ' ' +
                    wiki('Quests', 'quest') +
                    ', the Dailies will not hurt your fellow quest' +
                    ' participants.';
                var increase = 'To increase the effect of the skill, ' +
                               'increase your ' + perLink + before;
                return ['',
                        effects,
                        additional,
                        increase]; },
        };

        klassDone = {};
        klasses = [userKlass, 'healer', 'wizard', 'rogue', 'warrior'];
        for (var i in klasses) {
            var klassName = klasses[i];
            if (klassDone[klassName]) {
                continue;
            }
            klassDone[klassName] = true;
            html += '<h3>' + prettyPrintKlass(klassName) + ' Skills</h3>';
            for (var key in content.spells[klassName]) {
                var obj = content.spells[klassName][key];
                var skill = skills[obj.key]();
                var target = skill[0] ||
                    ((obj.target == 'self') ? 'yourself' : 'your '+obj.target);
                html += '<div class="subsection"><h4>' +
                        obj.text + '</h4>' +
                        '<p class="description">'   + obj.notes + '</p>' +
                        '<ul class="padded">' +
                        '<li><label>mana: </label>'   + obj.mana  + '</li>' +
                        '<li><label>target: </label>' + target    + '</li>' +
                        '<li><label>effect: </label>' + skill[1]  +
                            (skill[2] ? ' <span class="additional">' +
                             skill[2] + '</span>' : '') +
                            (skill[3] ? ' <span class="increase">' +
                             skill[3] + '</span>' : '') +
                            '</li>' +
                        '</ul></div>';
            }
            html += '<div class="clear"></div>';
        }
        TOC[orderId]  = {'target': id, 'title':  title};
        MAIN[orderId] = {'id': id, 'title': title, 'html': html};

        function crit(stat, chance) {
            // mimics the case where a critical hit DOES happen
            if (!stat) {
                stat = 'str';
            }
            if (!chance) {
                chance = 0.03
            }
            return 1.5 + (.02 * computedStats[stat]);
        }
    }
}


function dropCountAndCap() {
    var id      = 'dropsTodaySection';
    var orderId = 'dropsToday';
    var title   = 'Drops Received Today';
    var html = '<p>Drops received so far today: <span class="highlight">' +
               user.items.lastDrop.count +
               '</span></p><p>Your '  +
               wiki('Drops#Drop-Cap', 'drop-cap') +
               ' is <span class="highlight">';
    var dropCap = 5 + Math.floor(computedStats['per'] / 25) +
                  (user.contributor.level || 0);

    if (user.purchased.plan.customerId) {
        dropCap *= 2;
        html += dropCap +
               '</span>. It will increase if your ' +
               wiki('Perception', 'perception') +
               ' increases. Your perception is currently <a href="' +
               'https://habitica.com/#/options/profile/stats">' +
               computedStats['per'] + '</a>.</p>';
    }
    else {
        html += dropCap +
               '</span>. It will become <span class="highlight">' +
               (dropCap * 2) +
               '</span> if you ' +
               wiki('Subscription', 'subscribe') +
               '. You can also increase your drop-cap slightly ' +
               'by increasing your ' +
               wiki('Perception', 'perception') + '.</p>';
    }

    DASHBOARD[orderId] = {'id': 'dropsTodayDashboard',
        'label': 'Drop Count / Cap',
        'hoverText': 'drops you have received so far today ' +
                     '(click for more information)',
        'target': id,
        'hidden': hideDropsInDashboard,
        'value': ((user.items.lastDrop.count || 0) +
                 '<span class="dropCap"> / ' + dropCap + '</span>'),
        'status': ((user.items.lastDrop.count &&
                    user.items.lastDrop.count >= dropCap) ? 'safe' : 'neutral')
        };
    TOC[orderId]  = {'target': id, 'title':  title};
    MAIN[orderId] = {'id': id, 'title': title, 'html': html};
}


function questProgress() {
    var id            = 'questProgressSection';
    var title         = 'Quest Progress';
    var orderId       = 'questProgress';
    var orderIdSecond = 'questProgressSecond';
    var html = '<p>';

    var alreadyHaveDashboardTile = false;
    if (tavernBoss || (quest.content && quest.content.boss)) {
        var progress = Math.floor(questProgressUp * 10) / 10;
        // Round DOWN with floor so we don't let the user think they
        // have even slightly more progress than they really have.
        // Imagine if they missed ending a quest overnight by 0.1 health!
        html += 'So far today you have done an estimated ' +
               '<span class="highlight">' +
               progress + '</span> points of damage to ';
        if (quest.content && quest.content.boss) {
            var hp = Math.ceil(party.quest.progress.hp * 10) / 10;
            // Round the boss's HP remaining up so the user doesn't think
            // they're likely to complete the quest before they have.
            html += quest.content.boss.name || quest.content.key;
            html += ', who has ' + '<span class="highlight">' + hp + '</span> HP remaining'
            if (tavernBoss) {
                html += ', and the same amount of damage to ';
            }
        }
        if (tavernBoss) {
            html += "The Be-Wilder"; // XXX_LATER automate
        }
        html += '.';
        var dashboardTitle = 'Damage to ' + upperCaseFirst(bossesWord);
        DASHBOARD[orderId] = {'label': dashboardTitle,
            'hoverText': 'amount of damage you have done today to ' +
                         bossesLabel +
                         ' (click for more information)',
            'target': id, 'value': progress, 'status': 'neutral'};
        alreadyHaveDashboardTile = true;
    }

    if (userIsOnCollectionQuest) {
        if (tavernBoss) {
            html += '<br />';
        }
        html += 'So far today you have found ' + '<span class="highlight">';
        if (questProgressCollect === 0) {
            html += 'no';
        }
        else {
            html += questProgressCollect;
        }
        html += ' items</span> for the ' +
                (quest.content.text || quest.content.key) + ' quest.';

        var orderId1 = (alreadyHaveDashboardTile) ? orderIdSecond : orderId;
        var dashboardTitle = 'Quest Progress';
        DASHBOARD[orderId1] = {'label': dashboardTitle,
            'hoverText': 'number of items you have found today for your ' +
                         'collection quest (click for more information)',
            'target': id, 'value': questProgressCollect, 'status': 'neutral'};
    }
    html += '</p>';

    if (tavernBoss && tavern.quest.progress) {
        var name = "The Be-Wilder"; // XXX_LATER automate!
        var hp = Math.round(tavern.quest.progress.hp);
        var hpMax = 20000000; // XXX_LATER automate!
        var hpPercent = Math.round(hp / hpMax * 1000) / 10;
        if (hp > 0 && hpPercent == 0) { // XXX_LATER do this better
            hpPercent = Math.round(hp / hpMax * 10000) / 100;
            if (hpPercent == 0) {
                hpPercent = Math.round(hp / hpMax * 100000) / 1000;
                if (hpPercent == 0) {
                    hpPercent = Math.round(hp / hpMax * 1000000) / 10000;
                    if (hpPercent == 0) {
                        hpPercent = Math.round(hp / hpMax * 10000000) / 100000;
                    }
                }
            }
        }
        html += '<h3>Stats for ' + name + '</h3>' +
                '<p>Health: ' + hpPercent + '% (' +
                 hp + ', down from ' + hpMax + ')';
        if (tavern.quest.progress.rage) {
            var rage = Math.round(tavern.quest.progress.rage);
            var rageMax = 800000; // XXX_LATER automate!
            var ragePercent = Math.round(rage / rageMax * 1000) / 10;
            html += '<br />Beguilement: ' + ragePercent + '% (' + // XXX_LATER automate "Beguilement"
                    rage + ' out of ' + rageMax + ')';
        }
        html += '</p>';
    }

    if (html) {
        TOC[orderId]  = {'target': id, 'title':  title};
        MAIN[orderId] = {'id': id, 'title': title, 'html': html };
    }
}


function analyseEquipment() {
    var missing = []; // gear lost due to death or rebirth
    var missingPretty = []; // like missing but formatted
    var owned   = []; // gear actually owned right now
    $.each(user.items.gear.owned, function(key, value){
        if (value === false) {
            missing.push(key);
            missingPretty.push( prettyPrintKey(key, 'gear',
                            {'includeStats':true, 'includeGold':true, }) );
        }
        else {
            owned.push(key);
        }
    });
    missingEquipment(missing, missingPretty);
    currentEquipmentAndAppearance();
    recommendedEquipment(owned);


    function missingEquipment(equipment, equipmentPretty) {
        if (equipment.length < 1) {
            return; // no missing gear
        }
        var missingEquipmentObjs = [];
        var html = '';
        var reasons = wiki('Death_Mechanics', 'Death') +
                      ((user.achievements.rebirths > 0 ) ? ' or ' +
                      wiki('Orb_of_Rebirth', 'Rebirth')  : '');
        if (equipment.length < 4) {
            html = '<p>You are missing this equipment due to ' + reasons +
                   ':</p>' +
                   '<ul class="gearList"><li>' +
                   equipmentPretty.join('</li><li>') +
                   '</li></ul>';
        }
        else {
            html = '<p>The table below shows you the equipment you have lost due to ' + reasons + '. It can help you work out which pieces are best to buy back first to maximise the stats you care about while minimising the gold you spend.</p>' +
'<p>For equipment belonging to your current class, the CON, INT, PER, and STR columns show you the stats for the item modified by the ' +
wiki('Class_System#Class_Equip_Bonus', 'Class Equip Bonus') + '.</p>' +
'<p>The "<strong>can buy?</strong>" column categorises the equipment based on whether you can buy it now or not. There are three possible values:</p><ul>' +
'<li><strong>yes</strong>: you can buy it now (assuming you have enough gold)</li>' +
'<li><strong>later (buy other gear first)</strong>: you cannot buy it until you have bought other, cheaper versions of that equipment</li>' +
'<li><strong>no (wrong class)</strong>: you cannot buy it at all unless you change class</li>' +
'</ul>' +
'<p>Click on a column heading to sort by that column. Use the drop-down menus to filter the contents of the table. The "<strong>boosts stats?</strong>" drop-down menu will let you filter to show only equipment that increases your stats (i.e., to hide all stats-free gear). For more information about how to use this table, read the explanation for the "Task Overview" section, which has a table with similar features.</p>';
            html += '<table></table>';
            var canBuyUncertain = {};
            $.each(equipment, function(index,key){
                var obj = adjustEquipmentObject(key);
                if (obj.hasNoClass) {
                    obj.canBuy         = "yes";
                    obj.canBuyShort    = "yes";
                    obj.canBuySortable = "1 yes";
                }
                else if (! obj.isCurrentClass) {
                    obj.canBuy         = "no (wrong class)";
                    obj.canBuyShort    = "no";
                    obj.canBuySortable = "3 no";
                }
                else if (obj.special) {
                    obj.canBuy         = "yes";
                    obj.canBuyShort    = "yes";
                    obj.canBuySortable = "1 yes";
                }
                else {
                    // Equipment that is part of the normal progression of
                    // standard equipment - can buy it only if it's the lowest
                    // value item. Sort this out later:
                    if (! canBuyUncertain[obj.type]) {
                        canBuyUncertain[obj.type] = [];
                    }
                    canBuyUncertain[obj.type].push(obj);
                }
                if ((obj.con + obj.int + obj.per + obj.str) == 0) {
                    obj.boostsStats = 'no';
                }
                else {
                    obj.boostsStats = 'yes';
                }
                missingEquipmentObjs.push(obj);
            });
            $.each(canBuyUncertain, function(type){
                var cheapestFound = false;
                $.each(
                    canBuyUncertain[type].sort(function(a, b) {
                        return a.value - b.value || 1;
                    }), function(index,obj){
                    if (cheapestFound) {
                        obj.canBuy         = "later (buy other gear first)";
                        obj.canBuyShort    = "later";
                        obj.canBuySortable = "2 later";
                    }
                    else {
                        obj.canBuy         = "yes";
                        obj.canBuyShort    = "yes";
                        obj.canBuySortable = "1 yes";
                        cheapestFound = true;
                    }
                });
            });
        }
        var id    = 'missingEquipmentSection';
        var title = 'Missing Equipment';
        var orderId = 'missingEquipment';
        TOC[orderId] = {'target': id, 'title':  title};
        MAIN[orderId] = {'id': id, 'title': title, 'html': html};
        if (missingEquipmentObjs.length > 0) {
            MAIN[orderId]['function'] = createMissingEquipmentLotsTable;
        }

        function createMissingEquipmentLotsTable() {
            // Use DataTables to build the table (the table tag must be
            // visible first for layout to be correct):
            $('#missingEquipmentSection').show();
            $('#missingEquipmentSection table').dataTable({
                'fnRowCallback':
                    function(nRow, aData, iDisplayIndex, iDisplayIndexFull ) {
                        // give each row a class based on the type of gear:
                        $(nRow).addClass('canBuy_' + aData['canBuyShort']);
                        return nRow;
                    },
                'aaData': missingEquipmentObjs,
                'aoColumns': [
            { 'mData' : 'canBuySortable', 'bVisible': false, // for default sort
              'sTitle': 'canBuySortable', 'sClass': 'center',
            },
            { 'sTitle': 'type',       'sClass': 'center',
              'mData': function ( source, type, val ) {
                if (type === 'set') {
                  return; // http://datatables.net/ref#mData
                }
                return (source.type == 'weaponTwoHanded') ? 'weapon two-handed'
                     : (source.type == 'headAccessory'  ) ? 'head accessory'
                     :  source.type;
              }
            },
            { 'sTitle': 'image',      'sClass': 'center',
              'mData': function ( source, type, val ) {
                if (type === 'set') {
                  return; // http://datatables.net/ref#mData
                }
                return source.imgTag;
              }
            },
            { 'mData' : 'text',        'sClass': 'center',
              'sTitle': 'name',
            },
            { 'mData' : 'klassPretty', 'sClass': 'center',
              'sTitle': 'class',
            },
            { 'sTitle': 'can buy?',    'sClass': 'center',
              'mData': function ( source, type, val ) {
                if (type === 'set') {
                  return; // http://datatables.net/ref#mData
                }
                else if (type === 'sort') {
                  return source.canBuySortable;
                }
                return source.canBuy;
              }
            },
            { 'mData' : 'value',      'sClass': 'center',
              'sTitle': 'cost',
            },
            { 'mData' : 'con',        'sClass': 'center',
              'sTitle': 'CON',        'asSorting': ['desc','asc'],
            },
            { 'mData' : 'int',        'sClass': 'center',
              'sTitle': 'INT',        'asSorting': ['desc','asc'],
            },
            { 'mData' : 'per',        'sClass': 'center',
              'sTitle': 'PER',        'asSorting': ['desc','asc'],
            },
            { 'mData' : 'str',        'sClass': 'center',
              'sTitle': 'STR',        'asSorting': ['desc','asc'],
            },
            { 'mData' : 'boostsStats', 'bVisible': false,
              'sTitle': 'boosts stats?', 'sClass': 'center',
            },
            { 'mData' : 'attributesString',    'bVisible': false,
              'sTitle': 'attributes', 'sClass': 'center',
            },
            // { 'mData' : 'key',        'sClass': 'center',
              // 'sTitle': 'key',
            // }, // TST to view equipment keys
                ],
                'sDom': 'W<"clear"><"top"f>rt<"bottom"><"clear">',
                'bAutoWidth': false,
                'bPaginate': false,
                'bDeferRender': true,
                "sScrollX": "100%",
                "bDestroy": true,
                'oColumnFilterWidgets': {
                    'aiExclude': [ 0,2,3, 6,7,8,9,10 ],
                    "sSeparator": "\\s*/+\\s*",
                }
            });
            $('#missingEquipmentSection').hide();

            /*
            $('#missingEquipmentSection table tr.stats-free')
                                    .addClass('missingEquipmentHide');
            $('#missingEquipmentSection table tr.middling')
                                    .addClass('missingEquipmentHide');
            $('#missingEquipmentSection select.widget-8')
                                    .addClass('missingEquipmentHide');

            $('#showAllEquipment').click(function(event) {
                event.preventDefault();
                $('#missingEquipmentSection table tr.best td')
                                .addClass('missingEquipmentHighlight');
                $('#missingEquipmentSection table tr.stats-free')
                                .removeClass('missingEquipmentHide');
                $('#missingEquipmentSection table tr.middling')
                                .removeClass('missingEquipmentHide');
                $('#missingEquipmentSection select.widget-8')
                                .removeClass('missingEquipmentHide');
                $('#qualityFilter #onlyBestIsShowing').hide();
                $('#qualityFilter #allEquipmentIsShowing').show();
            });
            */

            return;
        }
    }


    function currentEquipmentAndAppearance() {
        // define avatar appearance options:
        var pastels = ['pblue','pgreen','porange','ppink','ppurple','pyellow'];
        var basicSkins = {'ddc994':'palest brown (1st)','f5a76e':'pink (2nd)',
                'ea8349':'orange (3rd)','c06534':'light brown (4th)',
                '98461a':'medium brown (5th)','915533':'dark brown (6th)',
                'c3e1dc':'blue (7th)','6bd049':'green (8th)'};
        var rainbowSkins = {'eb052b':'red','f69922':'orange','f5d70f':'yellow',
                '0ff591':'green','2b43f6':'blue','d7a9f7':'pink',
                '800ed0':'violet','rainbow':'rainbow'};
        var spookySkins= ['monster','pumpkin','skeleton','zombie',
                'ghost','shadow'];

        // collate appearance elements:
        var appearance = [ 'class: <span class="attributeValue">' +
                         prettyPrintKlass(userKlass) + '</span>' ];
        if (user.stats.buffs.snowball) {
            appearance.push('<span class="attributeValue">Snowball!</span>');
        }
        $.each([
            ['',      'size',         'build'                     ],
            ['',      'shirt',        'shirt'                     ],
            ['hair',  'color',        'hair colour'               ],
            ['hair',  'bangs',        'bangs',     'convertNumber'],
            ['hair',  'base',         'hair base', 'convertNumber'],
            ['hair',  'flower',       'flower',    'convertNumber'],
            ['hair',  'mustache',     'mustache',  'convertNumber'],
            ['hair',  'beard',        'beard',     'convertNumber'],
            ['',      'skin',         'skin colour'               ],
            ['',      'background',   'background'                ],
        ], function(index,obj) {
            var value;
            if (obj[0]) { value = user.preferences[obj[0]][obj[1]]; }
            else        { value = user.preferences[obj[1]];         }
            if (obj[1] == 'color' && ($.inArray(value, pastels) !== -1)) {
                value = value.replace(/^p/, "pastel ");
            }
            if (obj[3] == 'convertNumber') {
                value = convertCardinalToOrdinal(++value); // start from 1 not 0
                if (value == '1st') { value += ' (none)'; }
            }
            if (obj[1] == 'skin') {
                if ($.inArray(value, spookySkins) !== -1) {
                    value = 'spooky: ' + value;
                }
                else if (rainbowSkins[value]) {
                    value = 'rainbow: ' + rainbowSkins[value];
                }
                else if (basicSkins[value]) {
                    value = 'basic: ' + basicSkins[value];
                }
                // if no match, we use the skin key (e.g., f133ee)
            }
            if (obj[1] == 'background') {
                for (var setId in content.backgrounds) {
                    for (var backgroundId in content.backgrounds[setId]) {
                        if (backgroundId == value) {
                            value =
                                content.backgrounds[setId][backgroundId].text;
                        }
                    }
                }
            }
            if (value) {
                appearance.push(obj[2] + ': <span class="attributeValue">'
                                       + value + '</span>');
            }
        });
        var html = '';
        if (appearance.length > 0) {
            html += '<div class="subsection">'
                  + '<p class="forCopyPaste">&nbsp;</p>'
                  + '<h3>Avatar</h3><ul><li>'
                  + appearance.join('</li><li>')
                  + '</li></ul></div>';
        }

        var equipped = prettyPrintGear(user.items.gear.equipped);
        if (equipped) {
            html += '<div class="subsection gearList">'
                  + '<p class="forCopyPaste">&nbsp;</p>'
                  + '<h3>Battle Gear</h3>'
                  + equipped
                  + '</div>';
        }

        if (user.preferences.costume) {
            var costume = prettyPrintGear(user.items.gear.costume);
            if (costume) {
                html += '<div class="subsection gearList">'
                      + '<p class="forCopyPaste">&nbsp;</p>'
                      + '<h3>Costume</h3>'
                      + costume
                      + '</div>';
            }
        }

        var beasts = [];
        $.each([ 'currentMount', 'currentPet' ], function(index,type) {
            var value = user.items[type];
            if (value) {
                // improve display of beasts (BearCub-Red -> Red Bear Cub):
                var speciesAndColour = value.split('-');
                value = speciesAndColour[1] + speciesAndColour[0];
                value = value.replace(/([A-Z])/g, " $1"); // spaces before Caps
                value += (type == 'currentPet') ? ' pet' : ' mount';
                beasts.push(value);
            }
        });
        if (beasts.length > 0) {
            html += '<div class="subsection">'
                  + '<p class="forCopyPaste">&nbsp;</p>'
                  + '<h3>Beasts</h3><ul><li>'
                  + beasts.join('</li><li>')
                  + '</li></ul></div>';
        }

        html += '<div class="clear"></div>'

        var id    = 'currentGearSection';
        var title = 'Current Appearance and Gear';
        var orderId = 'currentGear';
        TOC[orderId] = {'target': id, 'title':  title};
        MAIN[orderId] = {'id': id, 'title': title, 'html': html};

        return;


        function convertCardinalToOrdinal(num) {
            var numStr = num.toString();
            var last   = numStr.slice(-1);
            var len    = numStr.length;
            var ord    = '';
            switch (last) {
                case '1':
                    ord = numStr.slice(-2) === '11' ? 'th' : 'st';
                    break;
                case '2':
                    ord = numStr.slice(-2) === '12' ? 'th' : 'nd';
                    break;
                case '3':
                    ord = numStr.slice(-2) === '13' ? 'th' : 'rd';
                    break;
                default:
                    ord = 'th';
                    break;
            }
            return num.toString() + ord;
        }


        function prettyPrintGear(origObj, nakedMessage) {
            var obj = $.extend({}, origObj);
            var result = [];
            // Go through gear in a specific order, and then handle any gear we
            // missed (e.g., if there's a new type of gear):
            $.each(['head','headAccessory','armor','weapon','shield','back'
            ], function(index,gearType){
                if (obj[gearType]) {
                    var html = prettyPrintOneGear(obj[gearType]);
                    if (html) { result.push(html); }
                    delete obj[gearType];
                }
            });
            $.each(obj, function(index,value){
                var html = prettyPrintOneGear(value);
                if (html) { result.push(html); }
            });

            if (result.length > 0) {
                return '<ul><li>'
                     + result.join('</li><li>')
                     + '</li></ul>';
            }
            else if (nakedMessage) {
                return '<p>' + nakedMessage + '</p>';
            }
            else {
                return false;
            }


            function prettyPrintOneGear(key) {
                if (key.match(/_base_0$/)) {
                    return false; // ignore "No Helm/Armour/etc"
                }
                var html = prettyPrintKey(key, 'gear');
                return html;
            }
        }
    }


    function recommendedEquipment(equipmentKeys) {
        var html =
'<div id="equipmentRecommendationsExplanationToggle" class="showHideToggle" data-target="equipmentRecommendationsExplanation" data-linktext="explanation">show explanation</div>' +
'<div id="equipmentRecommendationsExplanation" class="hide">' +
'    <p>This section helps you choose equipment to maximise specific attributes (for example, to maximise INT and CON before casting a healing spell).</p><p>By default, the table below shows you only the best equipment you have for each attribute. The attribute values include the class bonus for items belonging to your current class.</p><p>You can sort the table by clicking on a column heading, or filter it using the "type", "class", and "attributes" drop-down menus or the "search" text box (for more information about these features read the explanation for the Task Overview section on this page).</p><p>In addition, you can click on any row to highlight that row. This will also grey-out all other equipment that cannot be used at the same time as the item you have highlighted. However, you can still click on a grey row to change the highlighting. So, to use this table, try sorting it by the attribute you care most about, then highlight the top one or more items, and then if you care about another attribute too, re-sort by it and select more items.</p><p>All highlighted items are listed in a summary underneath the table, with the total attributes provided by those items. Next to the summary, you will find a button to clear all of your highlighted selections (it also clears the summary, so make note of it first if you need to).</p><p>Items that you are currently wearing are marked with *</p>' +
'   <div class="showHideToggle closer" data-target="equipmentRecommendationsExplanation" data-resettoggletext="equipmentRecommendationsExplanationToggle">hide explanation</div>' +
'</div>' +
'<div id="qualityFilter"><p id="onlyBestIsShowing">Only your best equipment is shown below. To maximise your attributes, choose from only those items.<br /><input id="showAllEquipment" type="submit" value="Show All of My Equipment" /></p><p id="allEquipmentIsShowing">All of your equipment is shown below. Use the "quality" drop-down menu to show only the best.</p></div>' +
'<table id="equipTable"></table>' +
'<div id="equipmentChosen"></div>' +
'<div class="clear"></div>';
// NB: id="equipTable" is necessary because DataTables inserts other table(s)
// and below we need to identify our own.

        var id      = 'equipmentRecommendationsSection';
        var title   = 'Equipment Recommendations';
        var orderId = 'equipmentRecommendations';
        TOC[orderId] = {'target': id, 'title':  title};
        MAIN[orderId] = {'id': id, 'title': title, 'html': html,
                   'function': createEquipmentRecommendationsTable};

        var aaData = collateEquipmentAndIdentifyBest(equipmentKeys);

        function createEquipmentRecommendationsTable() {
            // Use DataTables to build the table (the table tag must be
            // visible first for layout to be correct):
            $('#equipmentRecommendationsSection').show();
            $('#equipmentRecommendationsSection table').dataTable({
                'fnRowCallback':
                    function(nRow, aData, iDisplayIndex, iDisplayIndexFull ) {
                        // give each row a class based on the type of gear:
                        // and another based on the quality ('best', etc):
                        $(nRow).addClass(aData['type']);
                        $(nRow).addClass(aData['quality']);
                        // add 'data' to each row for later calculations etc:
                        $(nRow).data('type',   aData['type']);
                        $(nRow).data('name',   aData['text']);
                        $(nRow).data('con',    aData['con']);
                        $(nRow).data('int',    aData['int']);
                        $(nRow).data('per',    aData['per']);
                        $(nRow).data('str',    aData['str']);
                        $(nRow).data('key',    aData['key']);
                        $(nRow).data('imgTag', aData['imgTag']);
                        return nRow;
                    },
                'aaData': aaData,
                'aoColumns': [
            { 'sTitle': 'type',       'sClass': 'center',
              'mData': function ( source, type, val ) {
                if (type === 'set') {
                  return; // http://datatables.net/ref#mData
                }
                return (source.type == 'weaponTwoHanded') ? 'weapon two-handed'
                     : (source.type == 'headAccessory'  ) ? 'head accessory'
                     :  source.type;
              }
            },
            { 'sTitle': 'image',      'sClass': 'center', 'bSortable' : false,
              'mData': function ( source, type, val ) {
                if (type === 'set') {
                  return;
                }
                return source.imgTag;
              }
            },
            { 'mData' : 'text',       'sClass': 'center',
              'sTitle': 'name',
            },
            { 'mData' : 'klassPretty','sClass': 'center',
              'sTitle': 'class',
            },
            { 'mData' : 'con',        'sClass': 'center',
              'sTitle': 'CON',        'asSorting': ['desc','asc'],
            },
            { 'mData' : 'int',        'sClass': 'center',
              'sTitle': 'INT',        'asSorting': ['desc','asc'],
            },
            { 'mData' : 'per',        'sClass': 'center',
              'sTitle': 'PER',        'asSorting': ['desc','asc'],
            },
            { 'mData' : 'str',        'sClass': 'center',
              'sTitle': 'STR',        'asSorting': ['desc','asc'],
            },
            { 'mData' : 'attributesString',    'bVisible': false,
              'sTitle': 'attributes', 'sClass': 'center',
            },
            { 'mData' : 'quality',    'sClass': 'center',
              'sTitle': 'quality',
            },
            // { 'mData' : 'key',        'sClass': 'center',
              // 'sTitle': 'key',
            // }, // TST to view equipment keys
                ],
                'sDom': 'W<"clear"><"top"f>rt<"bottom"><"clear">',
                'bAutoWidth': false,
                'bPaginate': false,
                'bDeferRender': true,
                "sScrollX": "100%",
                "bDestroy": true,
                'oColumnFilterWidgets': {
                    'aiExclude': [ 1,2,4,5,6,7 ],
                    "sSeparator": "\\s*/+\\s*",
                }
            });
            $('#equipmentRecommendationsSection').hide();

            $('#equipmentRecommendationsSection table tr.stats-free')
                                    .addClass('equipmentRecommendationsHide');
            $('#equipmentRecommendationsSection table tr.middling')
                                    .addClass('equipmentRecommendationsHide');
            $('#equipmentRecommendationsSection select.widget-9')
                                    .addClass('equipmentRecommendationsHide');

            $('#showAllEquipment').click(function(event) {
                event.preventDefault();
                $('#equipmentRecommendationsSection table tr.best td')
                                .addClass('equipmentRecommendationsHighlight');
                $('#equipmentRecommendationsSection table tr.stats-free')
                                .removeClass('equipmentRecommendationsHide');
                $('#equipmentRecommendationsSection table tr.middling')
                                .removeClass('equipmentRecommendationsHide');
                $('#equipmentRecommendationsSection select.widget-9')
                                .removeClass('equipmentRecommendationsHide');
                $('#qualityFilter #onlyBestIsShowing').hide();
                $('#qualityFilter #allEquipmentIsShowing').show();
            });

            var twoHandedWeaponSelected = false;
            var oneHandedWeaponSelected = false;
            var shieldSelected          = false;
            $('#equipmentRecommendationsSection table#equipTable').on(
                                                'click', 'tr', function() {
                var type = $(this).data('type'); // armor, shield, etc
                if (! $(this).hasClass('rowHighlight')) {
                    // The user has clicked on a row that is not yet
                    // highlighted (i.e., the user wants that row to be
                    // highlighted). We add the highlight class to that row
                    // and remove it from any other rows for the same type of
                    // equipment. We add the lowlight class to all other
                    // rows for the same type of equipment (but not the row
                    // that the user clicked on).
                    $(this).siblings('.' + type).removeClass('rowHighlight')
                                                   .addClass('rowLowlight');
                    $(this).removeClass('rowLowlight')
                              .addClass('rowHighlight');
                    if (type == 'weaponTwoHanded') {
                        // The user has selected a two-handed weapon, so
                        // all shields and one-handed weapons are treated in
                        // the same way as non-selected two-handed weapons:
                        $(this).siblings('.shield').removeClass('rowHighlight')
                                                      .addClass('rowLowlight');
                        $(this).siblings('.weapon').removeClass('rowHighlight')
                                                      .addClass('rowLowlight');
                        twoHandedWeaponSelected = true;
                        oneHandedWeaponSelected = false;
                        shieldSelected          = false;
                    }
                    else if (type == 'weapon') {
                        // The user has selected a one-handed weapon, so
                        // all two-handed weapons are treated in the same way
                        // as non-selected one-handed weapons:
                        $(this).siblings('.weaponTwoHanded')
                                                .removeClass('rowHighlight')
                                                   .addClass('rowLowlight');
                        if (twoHandedWeaponSelected) {
                            // The user had previously selected a two-handed
                            // weapon, so shields would have been greyed out
                            // because of that, so now we must mark shields as
                            // able to be selected:
                            $(this).siblings('.shield')
                                                .removeClass('rowLowlight');
                            twoHandedWeaponSelected = false;
                        }
                        oneHandedWeaponSelected = true;
                    }
                    else if (type == 'shield') {
                        // The user has selected a shield, so
                        // all two-handed weapons are treated in the same way
                        // as non-selected shields:
                        // two-handed weapons as not able to be selected:
                        $(this).siblings('.weaponTwoHanded')
                                                   .removeClass('rowHighlight')
                                                      .addClass('rowLowlight');
                        if (twoHandedWeaponSelected) {
                            // The user had previously selected a two-handed
                            // weapon, so weaponds would have been greyed out
                            // because of that, so now we must mark weaponds as
                            // able to be selected:
                            $(this).siblings('.weapon')
                                                   .removeClass('rowLowlight');
                            twoHandedWeaponSelected = false;
                        }
                        shieldSelected = true;
                    }
                }
                else {
                    // The user has clicked on a row that was previously
                    // highlighted (i.e., that the user had previously clicked
                    // on) - so the user wants this row to no longer be
                    // highlighted. We remove the highlight class from the row.
                    // We also remove the lowlight class from rows for the same
                    // equipment type.
                    $(this).siblings('.' + type).removeClass('rowHighlight')
                                                .removeClass('rowLowlight');
                    $(this).removeClass('rowHighlight')
                           .removeClass('rowLowlight');
                    if (type == 'weaponTwoHanded') {
                        // The user has un-selected a two-handed weapon, so
                        // all shields and one-handed weapons (which were
                        // previously marked as unable to be selected) must
                        // have their lowlighting removed:
                        $(this).siblings('.shield').removeClass('rowLowlight');
                        $(this).siblings('.weapon').removeClass('rowLowlight');
                        twoHandedWeaponSelected = false;
                    }
                    else if (type == 'weapon') {
                        // The user has un-selected a one-handed weapon,
                        // so all two-handed weapons have their lowlighting
                        // removed UNLESS a shield is still selected:
                        if (! shieldSelected) {
                            $(this).siblings('.weaponTwoHanded')
                                                .removeClass('rowLowlight');
                        }
                        oneHandedWeaponSelected = false;
                    }
                    else if (type == 'shield') {
                        // The user has un-selected a shield,
                        // so all two-handed weapons have their lowlighting
                        // removed:
                        // UNLESS a one-handed weapon is still selected:
                        if (! oneHandedWeaponSelected) {
                            $(this).siblings('.weaponTwoHanded')
                                                .removeClass('rowLowlight');
                        }
                        shieldSelected = false;
                    }
                }
                sumEquipmentRecommendations();
            });

            return;
        }

        function sumEquipmentRecommendations() {
            var countCon = 0;
            var countInt = 0;
            var countPer = 0;
            var countStr = 0;
            var list     = '';
            var keys     = '';
            var images   = '';
            $('#equipmentRecommendationsSection table tr.rowHighlight').each(
                function(index,value){
                    keys     += $(this).data('key') + ' ';
                    images   += $(this).data('imgTag');
                    list     += '<li>' + $(this).data('name') + '</li>';
                    countCon += $(this).data('con');
                    countInt += $(this).data('int');
                    countPer += $(this).data('per');
                    countStr += $(this).data('str');
            });
            $('#equipmentRecommendationsSection #equipmentChosen').html(
                '<p><input id="equipmentChosenClear" type="submit"' +
                ' value="Clear All Selections" /></p>' +
                '<p>The equipment you have selected<br />' +
                'and the total stats they give are:</p>' +
                '<ul><li class="highlight">' +
                countCon + ' <span class="attributeName">con</span> ' +
                countInt + ' <span class="attributeName">int</span> ' +
                countPer + ' <span class="attributeName">per</span> ' +
                countStr + ' <span class="attributeName">str</span> ' +
                '<br /> &nbsp; ' +
                (countCon + countInt) +
                ' <span class="attributeName">con+int</span></li>' +
                list +
                '</ul>' +
                '<div id="equipmentChosenImages">' + images + '</div>' +
                '<p id="equipmentChosenKeys">API keys: ' + keys + '</p>'
            );
            $('#equipmentChosenClear').click( function(event) {
                event.preventDefault();
                twoHandedWeaponSelected = false;
                oneHandedWeaponSelected = false;
                shieldSelected          = false;
                $('#equipmentRecommendationsSection table tr').each(
                    function(index,value){
                        $(value).removeClass('rowHighlight')
                                .removeClass('rowLowlight')
                    }
                )
                $('#equipmentRecommendationsSection #equipmentChosen'
                        ).html('');
            });
        }

        function collateEquipmentAndIdentifyBest(equipmentKeys) {
            var template1 = {'stat':0, 'key':'', 'obj':{}};
            var template2 = { 'con': template1, // NB: the extend() 'deep copy'
                              'int': template1, // below will expand these
                              'per': template1, // out so they are no longer
                              'str': template1, // references to one object.
                            };
            var topEquipment = {
                'armor':           $.extend(true, {}, template2),
                'back':            $.extend(true, {}, template2),
                'body':            $.extend(true, {}, template2),
                'eyewear':         $.extend(true, {}, template2),
                'head':            $.extend(true, {}, template2),
                'headAccessory':   $.extend(true, {}, template2),
                'shield':          $.extend(true, {}, template2),
                'weapon':          $.extend(true, {}, template2),
                'weaponTwoHanded': $.extend(true, {}, template2),
            };
            var multiStatEquipment = []; // holds obj's

            var potentialItems = {};
            var allItems = []; // currently just for testing
            var equipmentObjs = [];
            $.each(equipmentKeys, function(index,key){
                if (content.gear.flat[key]) {
                    var obj = adjustEquipmentObject(key);

                    // identify equipment already being worn:
                    if (obj.beingWorn) {
                        obj.text += ' *';
                    }

                    // categorise the item's quality according to the stats it
                    // gives ('best', 'middling', 'stats-free'):
                    if ((obj.con + obj.int + obj.per + obj.str) == 0) {
                        obj['quality'] = 'stats-free';
                    }
                    else {
                        // Use item's stats to work out if it's the best we've
                        // found so far for this type, and if so, record its data
                        // (overwriting previously-found, less-good items).
                        // Also check to see how many kinds of attributes it
                        // gives - if more than two, we want it regardless of
                        // whether any of the attributes are best (gear that gives
                        // three or four attributes can be used for balanced stats).
                        var attributeCount = 0;
                        $.each(['con','int','per','str'], function(index, attr){
                            // NB: the adjustment above from 'weapon' to
                            // 'weaponTwoHanded' lets us capture the best gear
                            // for both one-hand and two-hand weapons:
                            if (obj[attr] > topEquipment[obj.type][attr]['stat']) {
                                topEquipment[obj.type][attr]['stat'] = obj[attr];
                                topEquipment[obj.type][attr]['key']  = key;
                                topEquipment[obj.type][attr]['obj']  = obj;
                            }
                            if (obj[attr] > 0) {
                                attributeCount++
                            }
                        });
                        if (attributeCount > 2) { // boosts more than 2 attributes
                            obj['quality'] = 'best';
                        }
                        else {
                            obj['quality'] = 'middling'; // might be changed to
                                // 'best' later when we have finished collating
                                // topEquipment
                        }
                    }
                    equipmentObjs.push(obj);
                }
            });

            // mark all top equipment as being of the 'best' quality:
            $.each(topEquipment, function(index, typeObj){
                $.each(typeObj, function(index,attrObj){
                    if (attrObj['key']) {
                        attrObj['obj']['quality'] = 'best';
                        // due to the magic of objects, this correctly adjusts
                        // the information in the equipmentObjs array
                    }
                });
            });

            return equipmentObjs;
        }
    }


    function adjustEquipmentObject(key) {
        var obj = $.extend({}, content.gear.flat[key]);
        if (! obj.text) {
            obj.text = prettyPrintKey(key, 'gear', {'nameOnly':true});
        }

        // adjust some equipment types:
        obj.origType = obj.type;
        if (obj.type == 'weapon' && obj.twoHanded) {
            obj.type = 'weaponTwoHanded';
        }

        // adjust equipment class && add class bonus:
        if (obj.klass == 'special') {
            // use the real character class for this item:
            obj.klass = obj.specialClass || 'none';
            obj.special = true;
        }
        if (obj.klass == userKlass) { // apply class bonus:
            obj.isCurrentClass = true;
            obj['con'] *= 1.5;
            obj['int'] *= 1.5;
            obj['per'] *= 1.5;
            obj['str'] *= 1.5;
        }
        if (obj.klass !== 'healer' && obj.klass !== 'rogue'  &&
            obj.klass !== 'mage'   && obj.klass !== 'wizard' &&
            obj.klass !== 'warrior'
        ) {
            obj.hasNoClass = true;
        }

        // adjust equipment names
        obj.plainText = obj.text;
        if (obj.type == 'weaponTwoHanded') {
            obj.text += ' <span class="lowlight">(two-handed)</span>';
            obj.plainText += ' (two-handed)';
        }
        if (obj.text =='Black Leather' || obj.text =='Oiled Leather') {
            obj.text += ' '  // add type of gear to the name:
                      + upperCaseFirst(obj.type);
            obj.plainText += ' '
                      + upperCaseFirst(obj.type);
        }
        if (obj.klass == 'rogue' &&
                (obj.type == 'weapon' || obj.type == 'shield')) {
            obj.text += ' <span class="lowlight">('
                      + obj.type + '-hand)</span>';
            obj.plainText += ' ('
                      + obj.type + '-hand)';
            // e.g., 'Kukri (shield-hand)' and 'Kukri (weapon-hand)'
        }

        // identify equipment already being worn:
        if (equippedKeys[key]) {
            obj.beingWorn = true;
        }

        // create a field that lists in one string the attributes
        // given by this item (for a filter drop-down menu):
        var attrs = [];
        $.each(['con','int','per','str'], function(index, attr){
            if (obj[attr]) {
                attrs.push(attr);
            }
        });
        obj.attributesString = attrs.join(' / ');

        // create an HTML img tag for the equipment's image:
        var url = 'https://habitica-assets.s3.amazonaws.com/mobileApp/images/' +
                  'shop_' + key + '.png';
        obj.imgTag = '<img src="' +
                     url + '" title="' +
                     obj.plainText + ' (' +
                     obj.key + ')" />';

        obj.klassPretty = prettyPrintKlass(obj.klass);

        return obj;
    }


    function prettyPrintKey(key, itemType, options) {
        // Takes a "key" (e.g., weapon_warrior_0) from Habitica's "content"
        // data and returns the name of the item (and sometimes other info).
        // If the name can't be found, it treats the key as the name.
        var name = '';
        var extra = '';  // e.g., for gear: klass and type (weapon/armor/etc)
        if (itemType == 'gear') {
            var obj = content.gear.flat[key];
            if (obj) {
                name = obj.text || key;
                if (options && options.nameOnly) {
              return name;
                }

                if (name == 'Mustaine\'s Milestone Mashing Morning Star') {
                    name = '<abbr title="' + name + '">Mashing Morning Star</a>';
                }
                if (name == 'Stephen Weber\'s Shaft of the Dragon') {
                    name = '<abbr title="' + name + '">Shaft of the Dragon</a>';
                }

                var type = obj.type;
                if (type == 'head') { type = 'headwear'; }
                extra = prettyPrintKlass(obj.klass);
                if (obj.klass == 'special' && obj.specialClass) {
                    extra += " " + prettyPrintKlass(obj.specialClass);
                }
                extra += " " + type;
                if (options && options.includeStats) {
                    extra += '; <span class="stats">'
                           + prettyPrintStats(obj,
                                {'includeGold':(options.includeGold || false)} )
                           + '</span>';
                }
            }
        }
        var html = '<span class="item">' +
                 '<span class="name">' + name + '</span>';
        if (extra) {
            html += ' <span class="extra">(' + extra + ')</span>';
        }
        html += ' <span class="key">{' + key + '}</span></span>';
        return html;


        function prettyPrintStats(obj, options) {
            var stats = [];
            if (options && options.includeGold) {
                stats.push(obj.value + " gp");
            }
            if (obj.con) { stats.push(obj.con + " con"); }
            if (obj.int) { stats.push(obj.int + " int"); }
            if (obj.per) { stats.push(obj.per + " per"); }
            if (obj.str) { stats.push(obj.str + " str"); }
            return stats.join(", ");
        }
    }
}


function subscriptionData() {
    var id      = 'subscriptionDataSection';
    var title   = 'Subscription Data';
    var orderId = 'subscriptionData';

    var subscriptionWarning = '';
    var subscriptionWarningFull = '';
    var html = '<p>If you are a subscriber, this section will show you ' +
               'the data Habitica has about your subscription. ' +
               'If you think any of it is not correct, please describe ' +
               'the problem at <a href="' +
               'https://habitica.com/#/options/groups/guilds/a29da26b-37de-4a71-b0c6-48e72a900dac' +
               '">Help > Report a Bug</a> from the website\'s menu or ' +
               '<strong>Guilds &gt; Report a Bug</strong> on the mobile ' +
               'app.</p>' +
               '<p>If you have been a subscriber in the past, this section ' +
               'might show some of your old data but that\'s not guaranteed. ' +
               'If you think you should still be a subscriber, ' +
               'please report it as described above.</p>';

    try {
        var plan = user.purchased.plan;

        var table = '';
        if (plan.dateCreated) {
            var date = moment(plan.dateCreated);
            if (date.isValid()) {
                table += '<tr><td>Date Created</td><td>' +
                         date.format('YYYY-MM-DD HH:MM') +
                         ' in your device\'s current time zone' +
                         '</td></tr>\n';
            }
        }

        if (plan.dateTerminated) {
            var date = moment(plan.dateTerminated);
            if (date.isValid()) {
                if (date.diff(moment(), 'days') <= 7) {
                    subscriptionWarning = 'Your subscription is ending soon.';
                    subscriptionWarningFull = 'Your Habitica subscription will end on ' +
                            date.format('YYYY-MM-DD') +
                            '. See the "Subscription Data" section for more details.';
                }
                table += '<tr><td>Termination Date</td><td>' +
                         date.format('YYYY-MM-DD HH:MM') +
                         ' in your device\'s current time zone' +
                         ' (if this is too early, immediately report it in the ' +
                         'Report a Bug guild - see above for how).</td></tr>\n';
            }
        }

        if (plan.paymentMethod) {
            table += '<tr><td>Payment Method</td><td>' +
                     plan.paymentMethod + '</td></tr>\n';
        }

        var giftAlreadyFound = false;
        if (plan.customerId) {
            if (plan.customerId === 'Gift' || plan.customerId === 'gift') {
                giftAlreadyFound = true;
                table += '<tr><td>Subscription Type</td><td>' +
                         'Gift' + '</td></tr>\n';
            }
        }

        if (plan.planId) {
            var types = {
                    'Gift': 'Gift',
                    'gift': 'Gift',
                    'basic': 'One-month recurring',
                    'basic_earned': 'One-month recurring',
                    'basic_3mo': 'Three-month recurring',
                    'basic_6mo': 'Six-month recurring',
                    'basic_12mo': 'Twelve-month recurring',
                };
            var description = '';
            if (types[plan.planId]) {
                description = types[plan.planId];
            }
            else {
                description = '"' + plan.planId + '"';
            }
            if (description === 'Gift' && giftAlreadyFound) {
                // display nothing - already displayed from the customerId
            }
            else {
                table += '<tr><td>Subscription Type</td><td>' +
                         description + '</td></tr>\n';
            }
        }

        if (plan.extraMonths) {
            var value = '';
            if (plan.extraMonths < 0) {
                value = 'Your subscription has a minor problem, which we can fix easily. Please go to the Report a Bug guild (see above for how), and paste in this text: "The Data Display Tool told me to report that my subscription has negative extraMonths." You do not need to say anything else.';
            }
            else if (plan.extraMonths > 0) {
                value = plan.extraMonths.toFixed(2);
            }
            if (value) {
                table += '<tr><td>Extra Months</td><td>' +
                         value + '</td></tr>\n';
            }
        }

        if (plan.consecutive) {
            if (typeof plan.consecutive.gemCapExtra !== 'undefined') {
                var total = 25 + plan.consecutive.gemCapExtra;
                table += '<tr><td>Total Monthly Gem Cap</td><td>' +
                         total +
                         ' (the base 25 per month + ' +
                         plan.consecutive.gemCapExtra + ' extra)</td></tr>\n';
            }

            if (plan.consecutive.count) {
                table += '<tr><td>Consecutive Months Subscribed</td><td>' +
                         plan.consecutive.count + '</td></tr>\n';
            }

            if (plan.consecutive.offset) {
                table += '<tr><td>Months Remaining</td><td>' +
                         plan.consecutive.offset + '</td></tr>\n';
            }
        }

        if (table) {
            html += '<table>' + table + '</table>';
        }
        else {
            html += 'No subscription data is recorded.';
        }

        if (subscriptionWarning) {
            html += '<p class="errorMessage">' + subscriptionWarning + '</p>';
            $('#subscriptionWarningFull').text(subscriptionWarningFull);
        }
        else {
            $('#subscriptionWarningFull').text(''); // required if user renews subscription then refetches data
        }

    } catch(err) {
        html += '<p><strong>Your subscription has unexpected information that can\'t be displayed. Please go to the Report a Bug guild (see above for how), and paste in this text: "The Data Display Tool told me to report that my subscription couldn\'t be displayed." You do not need to say anything else.</strong></p>';
        html += '<p>' + err + '</p>';
    }

    TOC[orderId]  = {'target': id, 'title':  title};
    MAIN[orderId] = {'id': id, 'title': title, 'html': html};
}


function computeStats(withBuffs) {
    // XXX make this be less hideously inefficient
    var computedStats = [];
    computedStats['con'] = computeStat('con', withBuffs, false);
    computedStats['int'] = computeStat('int', withBuffs, false);
    computedStats['per'] = computeStat('per', withBuffs, false);
    computedStats['str'] = computeStat('str', withBuffs, false);

    computedStats['details'] = {};
    computedStats.details['con'] = computeStat('con', withBuffs, true);
    computedStats.details['int'] = computeStat('int', withBuffs, true);
    computedStats.details['per'] = computeStat('per', withBuffs, true);
    computedStats.details['str'] = computeStat('str', withBuffs, true);
    computedStats.detailsPretty = {};

    computedStats.detailsPretty['con'] =
            prettifyStats(computedStats.details['con']);
    computedStats.detailsPretty['int'] =
            prettifyStats(computedStats.details['int']);
    computedStats.detailsPretty['per'] =
            prettifyStats(computedStats.details['per']);
    computedStats.detailsPretty['str'] =
            prettifyStats(computedStats.details['str']);

    return computedStats;

    function computeStat(stat, withBuffs, wantDetails) {
        var details = {};
        var level = (user.stats.lvl > 100) ? 100 : user.stats.lvl;
        details['allocated'] = user.stats[stat];
        if (withBuffs) {
            details['buffs'] = user.stats.buffs[stat];
        }
        else {
            details['buffs'] = 0;
        }
        details['level']     = Math.floor(level / 2);
        var computed = details['allocated']
                     + details['buffs']
                     + details['level'];
        // get appropriate stat for each piece of Battle Gear:
        details['equipment']  = 0;
        details['classBonus'] = 0;
        for(var key in equippedKeys) {
            var obj = equippedKeys[key];
            var value = obj[stat];
            details['equipment'] += value;
            if (obj.klass == userKlass || obj.specialClass == userKlass ) {
                details['classBonus'] += value * 0.5;
                value *= 1.5;
            }
            computed += value;
        }
        if (wantDetails) {
            return details;
        }
        else {
            return computed;
        }
    }

    function prettifyStats(details) {
        var pretty = '';
        var items = ['level', 'equipment', 'classBonus', 'allocated', 'buffs'];
        var names = ['Level', 'Equipment', 'Class Bonus', 'Allocated', 'Buffs'];
        for (var i=0,ic=items.length; i<ic; i++) {
            if (pretty) {
                pretty += '; &nbsp;';
            }
            pretty += names[i] + ': ' + details[ items[i] ];
        }
        return '(' + pretty + ')';
    }
}


function prettyPrintKlass(klass) {
    var prettyKlass;
    if (klass === 'wizard') {
        prettyKlass = 'Mage';
    }
    else if (klass == 'healer' || klass == 'rogue' || klass == 'warrior') {
        prettyKlass = upperCaseFirst(klass);
    }
    else {
        prettyKlass = klass;
    }
    return prettyKlass;
}


function diminishingReturns(bonus, max, halfway) {
    if (! halfway) {
        halfway = max / 2;
    }
    return max * bonus / (bonus + halfway);
}


function calculateBonus(value, stat, crit, stat_scale) {
    if (! crit) {
        crit = 1;
    }
    if (! stat_scale) {
        stat_scale = 0.5;
    }
    if (value < 0) {
        value = 1;
    }
    else {
        value += 1;
    }
    return value + stat * stat_scale * crit;
}


function convertTasksToApiV2Format() {
    // In Habitica's API v2, the tasks were stored as part of the user's
    // document, and everything in this tool was written based on that.
    // In API v3, they are stored separately, which is definitely better
    // but moving them back to the old format is the easiest way to
    // adapt this tool.
    // XXX_LATER Adapt this tool properly.

    var allV3Tasks = {};
    $.each(tasksFromDb, function(index, obj){
        allV3Tasks[obj._id] = obj;
    });

    user.habits = [];
    $.each(user.tasksOrder.habits, function(index, id){
        if (allV3Tasks[id]) {
            user.habits.push(allV3Tasks[id]);
        }
        else {
            console.log("missing Habit", id);
        }
    });

    user.dailys = [];
    $.each(user.tasksOrder.dailys, function(index, id){
        if (allV3Tasks[id]) {
            user.dailys.push(allV3Tasks[id]);
        }
        else {
            console.log("missing Daily", id);
        }
    });

    user.todos = [];
    $.each(user.tasksOrder.todos, function(index, id){
        if (allV3Tasks[id]) {
            user.todos.push(allV3Tasks[id]);
        }
        else {
            console.log("missing To-Do", id);
        }
    });
    $.each(completedTodosFromDb, function(index, obj){
        user.todos.push(obj);
    });

    user.rewards = [];
    $.each(user.tasksOrder.rewards, function(index, id){
        if (allV3Tasks[id]) {
            user.rewards.push(allV3Tasks[id]);
        }
        else {
            console.log("missing Reward", id);
        }
    });
}
} // end of parseData() and its nested functions
    if (debug) console.log('debug 99');
});
</script>

<style>

.popover { max-width:500px; }
.popover ol, .popover ul, .popover li {
    margin: 0 5px;
    padding: 5px;
}

/*********************************************************************
****   Page-wide   ***************************************************
*********************************************************************/

#innerBody {
    margin: 20px;
    padding: 5px 20px 30px 20px;
}
#loading {
    margin-right: 30px;
    margin-left: 30px;
    color: orange;
    font-size: 1.5em;
    font-weight: bold;
}
#loading ul {
    font-size: 0.8em;
}
#loading ul a {
    color: orange;
}


.narrowContent {      /* The data should be as wide as the user's window   */
    max-width: 500px; /* but some explanatory paragraphs should be narrow. */
}


hr {
    width: 95%;
}
hr.padded {
    margin-top:    1em;
    margin-bottom: 2em;
}

.show {
    display: block;
}
.hide {
    display: none;
}
.clear {
    clear: both;
}

.subheading {
    font-weight: bold;
}
.highlight {
    font-weight: bold;
}
.lowlight { /* like highlight but less so */
    font-style: italic;
}
.explanation {
    font-style: italic;
}
.errorMessage {
    color: orange;
    font-size: 18px;
    font-weight: bold;
}
abbr {
    border-bottom: 1px dashed black;
}
img.emoji {
    margin-bottom: -0.25em;
}
.forCopyPaste {
    /* used to add blank lines that we want when copying text to clipboard,
       but we don't want to see extra whitespace on the screen */
    margin-top: -1em;
}
ul.padded > li {
    padding: 3px 0;
}

p.taskName, p.taskNote {
    margin-top:    0.1em;
    margin-bottom: 0;
}

.gearList .item .stats {
    font-variant: small-caps;
}
.gearList .item .key {
    display: none;
}


.coloured {
    display: inline-block;
    width: 5.5em;
    height: 3em;
    padding-top: .1em;
}
.colourBrightBlue { background-color: rgb(209,226,248); }
.colourBlueGrey   { background-color: rgb(216,230,232); }
.colourGreen      { background-color: rgb(222,237,219); }
.colourYellow     { background-color: rgb(255,244,216); }
.colourOrange     { background-color: rgb(254,234,216); }
.colourRed        { background-color: rgb(250,214,214); }
.colourDarkRed    { background-color: rgb(240,197,190); }

.neutral {
    background-color: #fffbd0; /* yellow */
}
.danger {
    background-color: #ffcccc; /* red */
    /* background-color: #F5A9A9; */ /* darker red */
}
.safe {
    background-color: #bdd8fc; /* blue */
    /* green+red and green+yellow are not good for colour-blind people */
}


/*********************************************************************
****   Page-wide Show/Hide Toggling   ********************************
*********************************************************************/
.mainSectionClose,
.showHideToggle,     /* for toggling by id */
.showHideToggleClass /* for toggling by class */
{
    cursor: pointer;
    text-decoration: underline;
    color: purple;
}
.closer { /* as in "a thing that closes", not "nearer" */
    margin-top: 30px;
    padding-top: 15px;
    padding-bottom: 15px;
}
.closer:hover {
    border: 1px dashed lightgrey;
}
.developerData {
    font-family: monospace;
}


/*********************************************************************
****   Header   ******************************************************
*********************************************************************/
h1 {
    float: left;
}
h1>a:first-child { /* "Habitica" link in header */
    color: black;
    text-decoration: none;
}
h1>a:first-child:hover { /* "Habitica" link in header */
    text-decoration: underline;
}
h1 span {
    font-size: 0.5em;
}
h2 {
    margin-top: 30px;
}

#headerExtras .showHideToggle {
    white-space: nowrap;
}
#userNameDisplay {
    text-align: right;
    font-weight: bold;
    font-size: 2em;
    margin-bottom: 10px;
}

#explanationAndClearLinks {
    text-align: right;
}
#explanationAndClearLinks span {
    padding-left: 10px;
}


/*********************************************************************
****   Version History   *********************************************
*********************************************************************/

#versionChanges dl {
    margin-left: 30px;
}
#versionChanges dl dt {
    font-size: 1.15em;
    font-weight: bold;
}
#versionChanges dl dt .date {
    padding-left: 10px;
    font-size: 0.8em;
    font-weight: normal;
}
#versionChanges .showHideToggle {
    padding-bottom: 15px;
    margin-bottom: 10px;
}


/*********************************************************************
****   API Form and Documentation   **********************************
*********************************************************************/

#documentationAndForm > div {
    max-width: 700px;
}
#documentationAndForm #documentationAndFormClose {
    display: none;
    max-width: 100%;
}
#documentationAndForm div h2 {
    font-size: 1.3em;
}
#documentationAndForm li {
    margin-bottom: 10px;
}

#userApiDetailsForm {
    margin: 30px;
}
#userApiDetailsForm fieldset {
    max-width: 40em;
}
#userApiDetailsForm fieldset label,
#userApiDetailsForm fieldset input[type="submit"] {
    display: block;
    float: left;
    clear: left;
    margin: 10px 0;
}
#userApiDetailsForm fieldset label span {
    display: block;
    float: left;
    width: 6em;
}
#userApiDetailsForm fieldset label input {
    float: left;
    width: 30em;
}
#userApiDetailsForm fieldset p {
    clear: both;
}
#userApiDetailsForm legend .highlight {
    font-size: 1.3em;
}
#userApiDetailsForm fieldset li {
    margin-bottom: 7px;
}


/*********************************************************************
****   Dashboard   ***************************************************
*********************************************************************/
#DASHBOARD { float: right; }
#DASHBOARD ul {
    float: left;
}
#DASHBOARD li {
    text-align: center;
    width: 120px;
    border: 1px;
    padding: 4px;
    margin-right: 4px;
    float: left;
    list-style-type: none;
}
#DASHBOARD li.showHideToggle {
    text-decoration: none;
    color: black;
}
#DASHBOARD li > div {
    box-shadow: 1px 1px 1px 1px #666666;
}
#DASHBOARD .value {
    font-size: 2.15em;
    font-weight: bold;
    padding: 2px;
}
#DASHBOARD .label {
    font-size: 0.75em;
    padding: 1px;
    color: black;
}
#DASHBOARD .dropCap {
    font-size: 0.7em;
}


/*********************************************************************
****   Table Of Contents   *******************************************
*********************************************************************/

ul#tableOfContents {
    list-style-type: none;
}
ul#tableOfContents ul {
    list-style-type: none;
    margin-left: 1em;
    padding: 0;
}
ul#tableOfContents li {
    font-size: 1.1em;
    padding: 2px 0;
}
ul#tableOfContents > li {
    float: left;
    margin-right: 20px;
}


/*********************************************************************
****   Specific Sections   *******************************************
*********************************************************************/
#MAIN > * {
    display: none; // all sections hidden by default
}


#taskOverviewSection .showHideToggle {
    margin-bottom: 1em;
}
#taskOverviewDeveloperDataToggle {
    float: right;
}
#taskOverviewSection table {
    width: 100%;
    table-layout: fixed;
    word-wrap: break-word;
}
#taskOverviewSection table .sorting_1,
#taskOverviewSection table .sorting_2,
#taskOverviewSection table .sorting_3,
#taskOverviewSection table .even {
    background-color: #FAF9F9;
}
#taskOverviewSection table .odd  {
    background-color: #FEFEFF;
}
#taskOverviewSection input {
    width: 300px;
}
#taskOverviewSection table tr th:nth-child(3),
#taskOverviewSection table tr td:nth-child(3) {
    max-width: 60px !important;
}
#taskOverviewSection h3 {
    margin-top: 3em;
}
#taskOverviewSection .taskAttributes {
    float: right;
}
#taskOverviewSection .taskAttributes .attributeOn {
    opacity: 1;
}
#taskOverviewSection .taskAttributes .attributeOff {
    opacity: 0.4;
}
#taskOverviewSection .taskAttributes.habit span,
#taskOverviewSection .taskAttributes.daily span {
    border: solid 1px;
}
#taskOverviewSection .taskAttributes.habit span {
    padding: 0 4px;
}
#taskOverviewSection .taskAttributes.daily span {
    padding: 0 1px;
}


#taskStatisticsSection h3 {
    margin-top: 2em;
}
#taskStatisticsSection table {
    border: 1px solid black;
    border-collapse: collapse;
}
#taskStatisticsSection table tr th,
#taskStatisticsSection table tr td {
    padding: 3px 7px;
    border: 1px solid black;
    text-align: center;
}
#taskStatisticsSection table tr.total td {
    font-weight: bold;
    font-size: 1.1em;
    border-top:    2px solid black;
    border-bottom: 2px solid black;
}


#habitTrendsSection .legend {
    text-align: center;
}
#habitTrendsSection .legend-toggle {
    opacity: .4;
}
#habitTrendsSection button {
    border-radius: 7px;
}


#habitHistorySection .buttonUsed { /* which button (+ or -) was pressed */
    font-weight: bold;
}
#habitHistorySection .historyValue {
    font-size: .8em;
}
#habitHistorySection li li {
    padding: 1px 0;
}
#habitHistorySection .noHistory {
    font-weight: bold;
}
#habitHistorySection .noHistory span {
    font-size:  .8em;
    font-style: italic;
    font-weight: normal;
}


#dailiesIncompleteSection h3 {
    margin-top: 3em;
}
#dailiesIncompleteSection ul {
    list-style-type: none;
}
#dailiesIncompleteSection #greyDailies {
    margin-top: 3em;
}


#dailiesHistorySection > ul {
    list-style-type: none;
}
#dailiesHistorySection ul li span {
    display: inline-block;
    padding: 0.3em 0.7em;
    font-weight: bold;
    border: 1px solid #ccc;
    font-family: monospace;
}
#dailiesHistorySection table {
    margin-top: 1.5em;
    border-bottom: 1px solid #ccc;
    border-left:   1px solid #ccc;
}
#dailiesHistorySection table th {
    background-color: rgb(242, 242, 230); /* XXX_SOON replace with proper scrolling */
}
#dailiesHistorySection table th,
#dailiesHistorySection table td {
    text-align: center;
    border-top:   1px solid #ccc;
    border-right: 1px solid #ccc;
}
#dailiesHistorySection table th:first-child {
    border-right: 0.3em solid #999;
}
#dailiesHistorySection table td:first-child {
    text-align: left;
    border-right: 0.3em solid #999;
    display: inline-block;
    white-space: nowrap;
    overflow: hidden;
    width: 12em;
}
#dailiesHistorySection table th.missingDate,
#dailiesHistorySection table td.missingDate {
    border-left: 0.3em solid #999;
}


#todosDatedSection ul {
    list-style-type: none;
}
#todosDatedSection .due {
    font-weight: bold;
}
#todosDatedSection li span.date {
    display: inline-block;
    width: 7em;
}
#todosDatedSection li span.challenge {
    font-style: italic;
    font-variant: small-caps;
}
#todosDatedSection li p.taskName {
    display: inline;
}


#questProgressSection h3 {
    margin-top: 3em;
}


#statsAndStreaksSection .subsection {
    float: left;
    margin-left: 3em;
}
#statsAndStreaksSection ul {
    list-style-type: none;
    margin:  0;
    padding: 0;
}
#statsAndStreaksSection li span {
    display: inline-block;
    width: 4em;
}
#statsAndStreaksSection li p.taskName {
    display: inline;
}


#skillsAndBuffsSection .subsection {
    margin-left:  5em;
    margin-right: 5em;
}
#skillsAndBuffsSection h3:first-of-type {
    margin-top: 2em;
}
#skillsAndBuffsSection h3 {
    font-size: 1.3em;
    margin-top: 3em;
}
#skillsAndBuffsSection h4 {
    margin-left: -2em;
    font-size: 1.2em;
}
#skillsAndBuffsSection .description {
    font-style: italic;
}
#skillsAndBuffsSection ul {
    list-style-type: none;
    margin:  0;
    padding: 0;
}
#skillsAndBuffsSection ul li {
    font-weight: bold;
}
#skillsAndBuffsSection ul li label {
    display: inline-block;
    width: 4em;
    font-weight: normal;
}
#skillsAndBuffsSection ul li .details {
    font-weight: normal;
}
#skillsAndBuffsSection ul.attributes li {
    margin-left: 5em;
    margin-bottom: 0.5em;
}
#skillsAndBuffsSection ul.attributes li label {
    width: 10em;
}
#skillsAndBuffsSection ul li .additional,
#skillsAndBuffsSection ul li .increase   {
    margin-top: 0.5em;
    display: block;
    font-weight: normal;
}
#skillsAndBuffsSection ul li a {
    white-space: nowrap;
}
#skillsAndBuffsSection span.taskName {
    font-weight: normal;
    font-style: italic;
}
#skillsAndBuffsSection li p.taskName {
    display: inline;
}


#missingEquipmentSection ul.gearList  {
    list-style-type: none;
}
#missingEquipmentSection .gearList .item .name {
    font-weight: bold;
}
#missingEquipmentSection .gearList .item .extra {
}

#missingEquipmentSection table {
    border-spacing: 0;
}
#missingEquipmentSection table tr td {
    border-bottom: 1px solid lightgrey;
    padding-top:    0;
    padding-bottom: 0;
}
#missingEquipmentSection table tr.even.canBuy_yes,
#missingEquipmentSection table tr.even.canBuy_yes .sorting_1,
#missingEquipmentSection table tr.even.canBuy_yes .sorting_2,
#missingEquipmentSection table tr.even.canBuy_yes .sorting_3,
#missingEquipmentSection table tr.even.canBuy_yes .sorting_4,
#missingEquipmentSection table tr.even.canBuy_yes .sorting_5,
#missingEquipmentSection table tr.even.canBuy_yes .sorting_6,
#missingEquipmentSection table tr.odd.canBuy_yes,
#missingEquipmentSection table tr.odd.canBuy_yes .sorting_1,
#missingEquipmentSection table tr.odd.canBuy_yes .sorting_2,
#missingEquipmentSection table tr.odd.canBuy_yes .sorting_3,
#missingEquipmentSection table tr.odd.canBuy_yes .sorting_4,
#missingEquipmentSection table tr.odd.canBuy_yes .sorting_5,
#missingEquipmentSection table tr.odd.canBuy_yes .sorting_6 {
    background-color: rgb(242, 242, 230); /* yellowish */
    color: black;
    font-style: normal;
    font-weight: bold;
}
#missingEquipmentSection table tr.even.canBuy_later,
#missingEquipmentSection table tr.even.canBuy_later .sorting_1,
#missingEquipmentSection table tr.even.canBuy_later .sorting_2,
#missingEquipmentSection table tr.even.canBuy_later .sorting_3,
#missingEquipmentSection table tr.even.canBuy_later .sorting_4,
#missingEquipmentSection table tr.even.canBuy_later .sorting_5,
#missingEquipmentSection table tr.even.canBuy_later .sorting_6,
#missingEquipmentSection table tr.odd.canBuy_later,
#missingEquipmentSection table tr.odd.canBuy_later .sorting_1,
#missingEquipmentSection table tr.odd.canBuy_later .sorting_2,
#missingEquipmentSection table tr.odd.canBuy_later .sorting_3,
#missingEquipmentSection table tr.odd.canBuy_later .sorting_4,
#missingEquipmentSection table tr.odd.canBuy_later .sorting_5,
#missingEquipmentSection table tr.odd.canBuy_later .sorting_6 {
    background-color: rgb(242, 242, 230) !important; /* yellowish */
    // background-color: rgb(173, 208, 215); /* bluish */
    color: black;
    font-style: italic;
    font-weight: normal;
}
#missingEquipmentSection table tr.even.canBuy_no,
#missingEquipmentSection table tr.even.canBuy_no .sorting_1,
#missingEquipmentSection table tr.even.canBuy_no .sorting_2,
#missingEquipmentSection table tr.even.canBuy_no .sorting_3,
#missingEquipmentSection table tr.even.canBuy_no .sorting_4,
#missingEquipmentSection table tr.even.canBuy_no .sorting_5,
#missingEquipmentSection table tr.even.canBuy_no .sorting_6,
#missingEquipmentSection table tr.odd.canBuy_no,
#missingEquipmentSection table tr.odd.canBuy_no .sorting_1,
#missingEquipmentSection table tr.odd.canBuy_no .sorting_2,
#missingEquipmentSection table tr.odd.canBuy_no .sorting_3,
#missingEquipmentSection table tr.odd.canBuy_no .sorting_4,
#missingEquipmentSection table tr.odd.canBuy_no .sorting_5,
#missingEquipmentSection table tr.odd.canBuy_no .sorting_6 {
    background-color: #E8E8E8; /* pale grey */
    color: #909090; /* darker grey */
    font-style: italic;
    font-weight: normal;
}


#currentGearSection .subsection {
    float: left;
    margin-right: 2em;
}
#currentGearSection ul {
    list-style-type: none;
    margin:  0;
    padding: 0;
}
#currentGearSection .gearList .item .extra {
    font-style: italic;
}
#currentGearSection .attributeValue {
    font-weight: bold;
}


#equipmentRecommendationsSection #qualityFilter {
    text-align: center;
    margin-top: 2em;
    font-size: 1.2em;
}
#equipmentRecommendationsSection #allEquipmentIsShowing {
    display: none;
}
#equipmentRecommendationsSection #onlyBestIsShowing {
}
#equipmentRecommendationsSection table tr td {
    border-bottom: 1px solid lightgrey;
}
#equipmentRecommendationsSection table tr td img {
    height: 50%;
}
#equipmentRecommendationsSection table tr.even,
#equipmentRecommendationsSection table tr.even .sorting_1,
#equipmentRecommendationsSection table tr.even .sorting_2,
#equipmentRecommendationsSection table tr.even .sorting_3,
#equipmentRecommendationsSection table tr.even .sorting_4,
#equipmentRecommendationsSection table tr.even .sorting_5,
#equipmentRecommendationsSection table tr.even .sorting_6,
#equipmentRecommendationsSection table tr.odd,
#equipmentRecommendationsSection table tr.odd  .sorting_1,
#equipmentRecommendationsSection table tr.odd  .sorting_2,
#equipmentRecommendationsSection table tr.odd  .sorting_3,
#equipmentRecommendationsSection table tr.odd  .sorting_4,
#equipmentRecommendationsSection table tr.odd  .sorting_5,
#equipmentRecommendationsSection table tr.odd  .sorting_6 {
    background-color: rgb(242, 242, 230); /* yellowish */
    color: black;
    font-style: normal;
    font-weight: normal;
}
#equipmentRecommendationsSection table .rowLowlight,
#equipmentRecommendationsSection table .rowLowlight .sorting_1,
#equipmentRecommendationsSection table .rowLowlight .sorting_2,
#equipmentRecommendationsSection table .rowLowlight .sorting_3,
#equipmentRecommendationsSection table .rowLowlight .sorting_4,
#equipmentRecommendationsSection table .rowLowlight .sorting_5,
#equipmentRecommendationsSection table .rowLowlight .sorting_6 {
    background-color: #E8E8E8 !important; /* pale grey */
    color: #C0C0C0 !important; /* darker grey */
    font-style: italic !important;
    font-weight: normal !important;
}
#equipmentRecommendationsSection table .rowHighlight,
#equipmentRecommendationsSection table .rowHighlight .sorting_1,
#equipmentRecommendationsSection table .rowHighlight .sorting_2,
#equipmentRecommendationsSection table .rowHighlight .sorting_3,
#equipmentRecommendationsSection table .rowHighlight .sorting_4,
#equipmentRecommendationsSection table .rowHighlight .sorting_5,
#equipmentRecommendationsSection table .rowHighlight .sorting_6 {
    background-color: rgb(173, 208, 215) !important; /* bluish */
    color: black !important;
    font-style: normal !important;
    font-weight: bold !important;
}
.equipmentRecommendationsHighlight {
    font-weight: bold !important;
}
.equipmentRecommendationsHide { /* initially show only the best gear */
    display: none !important;
}

#equipmentRecommendationsSection #equipmentChosen {
    margin-top: 1.5em;
}
#equipmentRecommendationsSection #equipmentChosen p,
#equipmentRecommendationsSection #equipmentChosen ul {
    width: auto;
    float: left;
    margin-right: 2em;
}
#equipmentRecommendationsSection #equipmentChosen ul {
    list-style-type: none;
    font-size:  1.2em;
    margin: 0;
    padding: 0;
}
#equipmentRecommendationsSection #equipmentChosen ul li {
    padding-bottom: 3px;
}
#equipmentRecommendationsSection #equipmentChosen ul li.highlight {
    padding-bottom:  9px;
}
#equipmentRecommendationsSection #equipmentChosen .attributeName {
    font-variant: small-caps;
    padding-right: 10px;
}
#equipmentRecommendationsSection #equipmentChosen div#equipmentChosenImages {
    float: right;
}
#equipmentRecommendationsSection #equipmentChosen p#equipmentChosenKeys {
    clear: both;
    font-size:  0.8em;
    font-style: italic;
}

#subscriptionDataSection table {
    padding-top: 1em;
}
#subscriptionDataSection table tr td:nth-child(1) {
    text-align: right;
    padding-right: 0.8em;
}
#subscriptionDataSection table tr td:nth-child(2) {
    font-weight: bold;
}

</style>
<div id="innerBody">

	<h1><a href="https://habitica.com/" target='_blank'>Habitica</a>, </h1>
	<div id="headerExtras"></div>
	<hr class="clear" />
	<div id="subscriptionWarningFull" class="errorMessage"></div>
	<div id="loading">
	    <div class="good">
	        <p>Please wait. Fetching data from
	        <span id="serverName">Habitica</span>...</p>
	    </div>
	    <div class="bad hide">
	        <p>There was an error obtaining your data.</p>
	        <ul class="padded">
	            <li>Please reload the page and then check that your <a href="https://habitica.com/#/options/settings/api">User ID and API Token</a> are correct.</li>
	        </ul>
	    </div>
	</div>

	<div id="DASHBOARD"></div>
	<div id="TOC"></div>
	<div id="MAIN"></div>
</div>